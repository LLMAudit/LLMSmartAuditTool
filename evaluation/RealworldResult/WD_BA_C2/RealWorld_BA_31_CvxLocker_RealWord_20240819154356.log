[2024-19-08 15:43:57 INFO] **[Preprocessing]**

**ChatDev Starts** (20240819154356)

**Timestamp**: 20240819154356

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}


**project_name**: RealWorld_BA_31_CvxLocker

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_31_CvxLocker_RealWord_20240819154356.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-19-08 15:43:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    / ========== STATE VARIABLES ========== /\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    / ========== CONSTRUCTOR ========== /\n\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    / ========== ADMIN CONFIGURATION ========== /\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n\n    / ========== VIEWS ========== /\n\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    / ========== MUTATIVE FUNCTIONS ========== /\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n\n        if (total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    / ========== RESTRICTED FUNCTIONS ========== /\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n\n        emit RewardAdded(_rewardsToken, _reward);\n\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    / ========== MODIFIERS ========== /\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:43:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:43:57 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-19-08 15:44:05 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:44:05 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15316
completion_tokens: 471
total_tokens: 15787
cost: $-1.000000


[2024-19-08 15:44:05 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Let's analyze the provided Solidity contract and identify potential areas for improvement or enhancement.

1. **Upgrade to a Newer Solidity Version**: The contract is currently using Solidity version 0.6.12. Upgrading to a newer version (e.g., 0.8.x) could provide benefits such as built-in overflow checks, which enhance security and reduce the need for external libraries like BoringMath.

2. **Use of Events**: While the contract does emit events for significant actions, we could consider adding more events for actions like `lock`, `unlock`, and `approveRewardDistributor`. This would improve transparency and allow for better tracking of contract interactions.

3. **Gas Optimization**: The contract has several loops that could be optimized for gas efficiency. For instance, in functions like `balanceOf` and `lockedBalances`, we could consider using a more efficient data structure or approach to minimize the number of iterations.

4. **Reentrancy Guard on Critical Functions**: Although the contract uses `ReentrancyGuard`, we should ensure that all functions that interact with external contracts (like `transfer`, `approve`, etc.) are adequately protected against reentrancy attacks.

5. **Access Control**: The `onlyOwner` modifier is used extensively. We could consider implementing a multi-signature wallet for critical functions to enhance security and prevent a single point of failure.

6. **Emergency Withdrawals**: Implementing an emergency withdrawal function that allows users to withdraw their tokens in case of a contract malfunction or exploit could be beneficial for user trust.

7. **Detailed Documentation**: Adding more comments and documentation within the code would help future developers understand the logic and purpose of various functions and state variables.

8. **Testing for Edge Cases**: Ensure that the contract is thoroughly tested for edge cases, especially around time-based functions (like epoch calculations) and reward distributions.

9. **Audit Trail**: Implement a mechanism to log changes to critical parameters (like `maximumBoostPayment`, `boostRate`, etc.) to provide an audit trail for governance and transparency.

10. **User-Friendly Error Messages**: Instead of generic error messages, we could provide more descriptive error messages to help users understand what went wrong during transactions.

Which of these suggestions do you find most impactful, or do you have any additional ideas to discuss?

[2024-19-08 15:44:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    / ========== STATE VARIABLES ========== /\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n    //shutdown\n    bool public isShutdown = false;\n    //erc20-like interface\n    string private name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n    / ========== CONSTRUCTOR ========== /\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    / ========== ADMIN CONFIGURATION ========== /\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n        stakingProxy = _staking;\n    }\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n    / ========== VIEWS ========== /\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n        return amount;\n    }\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n        return amount;\n    }\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n        return supply;\n    }\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n        return supply;\n    }\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n    / ========== MUTATIVE FUNCTIONS ========== /\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n        Balances storage bal = balances[_account];\n        //must try check pointing epoch first\n        _checkpointEpoch();\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n        emit Withdrawn(_account, locked, _relock);\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n        if (total == 0) return;\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n    / ========== RESTRICTED FUNCTIONS ========== /\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n        _notifyReward(_rewardsToken, _reward);\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n        emit RewardAdded(_rewardsToken, _reward);\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n    / ========== MODIFIERS ========== /\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    / ========== STATE VARIABLES ========== /\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n    //shutdown\n    bool public isShutdown = false;\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n    / ========== CONSTRUCTOR ========== /\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    / ========== ADMIN CONFIGURATION ========== /\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n        stakingProxy = _staking;\n    }\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n    / ========== VIEWS ========== /\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n        return amount;\n    }\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n        return amount;\n    }\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n        return supply;\n    }\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n        return supply;\n    }\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n    / ========== MUTATIVE FUNCTIONS ========== /\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n        Balances storage bal = balances[_account];\n        //must try check pointing epoch first\n        _checkpointEpoch();\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n        emit Withdrawn(_account, locked, _relock);\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n        if (total == 0) return;\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n    / ========== RESTRICTED FUNCTIONS ========== /\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n        _notifyReward(_rewardsToken, _reward);\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n        emit RewardAdded(_rewardsToken, _reward);\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n    / ========== MODIFIERS ========== /\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s analyze the provided Solidity contract and identify potential areas for improvement or enhancement.\n1. Upgrade to a Newer Solidity Version: The contract is currently using Solidity version 0.6.12. Upgrading to a newer version (e.g., 0.8.x) could provide benefits such as built-in overflow checks, which enhance security and reduce the need for external libraries like BoringMath.\n2. Use of Events: While the contract does emit events for significant actions, we could consider adding more events for actions like lock, unlock, and approveRewardDistributor. This would improve transparency and allow for better tracking of contract interactions.\n3. Gas Optimization: The contract has several loops that could be optimized for gas efficiency. For instance, in functions like balanceOf and lockedBalances, we could consider using a more efficient data structure or approach to minimize the number of iterations.\n4. Reentrancy Guard on Critical Functions: Although the contract uses ReentrancyGuard, we should ensure that all functions that interact with external contracts (like transfer, approve, etc.) are adequately protected against reentrancy attacks.\n5. Access Control: The onlyOwner modifier is used extensively. We could consider implementing a multi-signature wallet for critical functions to enhance security and prevent a single point of failure.\n6. Emergency Withdrawals: Implementing an emergency withdrawal function that allows users to withdraw their tokens in case of a contract malfunction or exploit could be beneficial for user trust.\n7. Detailed Documentation: Adding more comments and documentation within the code would help future developers understand the logic and purpose of various functions and state variables.\n8. Testing for Edge Cases: Ensure that the contract is thoroughly tested for edge cases, especially around time-based functions (like epoch calculations) and reward distributions.\n9. Audit Trail: Implement a mechanism to log changes to critical parameters (like maximumBoostPayment, boostRate, etc.) to provide an audit trail for governance and transparency.\n10. User-Friendly Error Messages: Instead of generic error messages, we could provide more descriptive error messages to help users understand what went wrong during transactions.\nWhich of these suggestions do you find most impactful, or do you have any additional ideas to discuss?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:44:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:44:05 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;
    /* ========== STATE VARIABLES ========== */
    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }
    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);
    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;
    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;
    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;
    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;
    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;
    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;
    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing
    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;
    //shutdown
    bool public isShutdown = false;
    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;
    /* ========== CONSTRUCTOR ========== */
    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }
    function decimals() public view returns (uint8) {
        return _decimals;
    }
    function name() public view returns (string memory) {
        return _name;
    }
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    /* ========== ADMIN CONFIGURATION ========== */
    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }
    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }
    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");
        stakingProxy = _staking;
    }
    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }
    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }
    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }
    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }
    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));
        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }
    /* ========== VIEWS ========== */
    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }
    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }
    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }
    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }
    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }
    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }
    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }
    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }
    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }
    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        //start with current boosted amount
        amount = balances[_user].boosted;
        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }
        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }
        return amount;
    }
    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];
        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);
        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }
        return amount;
    }
    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;
        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }
        return supply;
    }
    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }
        return supply;
    }
    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;
        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);
        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;
            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }
    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }
    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }
    /* ========== MUTATIVE FUNCTIONS ========== */
    function checkpointEpoch() external {
        _checkpointEpoch();
    }
    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;
        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }
            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }
    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        //lock
        _lock(_account, _amount, _spendRatio);
    }
    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");
        Balances storage bal = balances[_account];
        //must try check pointing epoch first
        _checkpointEpoch();
        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();
        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);
        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);
        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }
        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));
        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }
        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);
        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }
    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;
        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;
            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();
            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;
                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);
                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");
        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);
        emit Withdrawn(_account, locked, _relock);
        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());
            //transfer reward
            transferCVX(_rewardAddress, reward, false);
            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }
        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }
    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }
    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }
    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }
    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }
    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);
        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }
    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;
        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);
        if (total == 0) return;
        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }
    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }
    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }
    /* ========== RESTRICTED FUNCTIONS ========== */
    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];
        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }
        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }
    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");
        _notifyReward(_rewardsToken, _reward);
        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );
        emit RewardAdded(_rewardsToken, _reward);
        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }
    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }
    /* ========== MODIFIERS ========== */
    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }
    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;
    /* ========== STATE VARIABLES ========== */
    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }
    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);
    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;
    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;
    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;
    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;
    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;
    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;
    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing
    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;
    //shutdown
    bool public isShutdown = false;
    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;
    /* ========== CONSTRUCTOR ========== */
    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }
    function decimals() public view returns (uint8) {
        return _decimals;
    }
    function name() public view returns (string memory) {
        return _name;
    }
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    /* ========== ADMIN CONFIGURATION ========== */
    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }
    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }
    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");
        stakingProxy = _staking;
    }
    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }
    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }
    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }
    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }
    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));
        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }
    /* ========== VIEWS ========== */
    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }
    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }
    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }
    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }
    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }
    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }
    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }
    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }
    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }
    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        //start with current boosted amount
        amount = balances[_user].boosted;
        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }
        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }
        return amount;
    }
    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];
        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);
        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }
        return amount;
    }
    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;
        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }
        return supply;
    }
    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }
        return supply;
    }
    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;
        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);
        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;
            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }
    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }
    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }
    /* ========== MUTATIVE FUNCTIONS ========== */
    function checkpointEpoch() external {
        _checkpointEpoch();
    }
    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;
        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }
            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }
    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        //lock
        _lock(_account, _amount, _spendRatio);
    }
    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");
        Balances storage bal = balances[_account];
        //must try check pointing epoch first
        _checkpointEpoch();
        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();
        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);
        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);
        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }
        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));
        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }
        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);
        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }
    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;
        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;
            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();
            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;
                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);
                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");
        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);
        emit Withdrawn(_account, locked, _relock);
        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());
            //transfer reward
            transferCVX(_rewardAddress, reward, false);
            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }
        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }
    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }
    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }
    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }
    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }
    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);
        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }
    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;
        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);
        if (total == 0) return;
        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }
    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }
    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }
    /* ========== RESTRICTED FUNCTIONS ========== */
    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];
        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }
        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }
    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");
        _notifyReward(_rewardsToken, _reward);
        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );
        emit RewardAdded(_rewardsToken, _reward);
        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }
    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }
    /* ========== MODIFIERS ========== */
    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }
    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's analyze the provided Solidity contract and identify potential areas for improvement or enhancement.
1. **Upgrade to a Newer Solidity Version**: The contract is currently using Solidity version 0.6.12. Upgrading to a newer version (e.g., 0.8.x) could provide benefits such as built-in overflow checks, which enhance security and reduce the need for external libraries like BoringMath.
2. **Use of Events**: While the contract does emit events for significant actions, we could consider adding more events for actions like `lock`, `unlock`, and `approveRewardDistributor`. This would improve transparency and allow for better tracking of contract interactions.
3. **Gas Optimization**: The contract has several loops that could be optimized for gas efficiency. For instance, in functions like `balanceOf` and `lockedBalances`, we could consider using a more efficient data structure or approach to minimize the number of iterations.
4. **Reentrancy Guard on Critical Functions**: Although the contract uses `ReentrancyGuard`, we should ensure that all functions that interact with external contracts (like `transfer`, `approve`, etc.) are adequately protected against reentrancy attacks.
5. **Access Control**: The `onlyOwner` modifier is used extensively. We could consider implementing a multi-signature wallet for critical functions to enhance security and prevent a single point of failure.
6. **Emergency Withdrawals**: Implementing an emergency withdrawal function that allows users to withdraw their tokens in case of a contract malfunction or exploit could be beneficial for user trust.
7. **Detailed Documentation**: Adding more comments and documentation within the code would help future developers understand the logic and purpose of various functions and state variables.
8. **Testing for Edge Cases**: Ensure that the contract is thoroughly tested for edge cases, especially around time-based functions (like epoch calculations) and reward distributions.
9. **Audit Trail**: Implement a mechanism to log changes to critical parameters (like `maximumBoostPayment`, `boostRate`, etc.) to provide an audit trail for governance and transparency.
10. **User-Friendly Error Messages**: Instead of generic error messages, we could provide more descriptive error messages to help users understand what went wrong during transactions.
Which of these suggestions do you find most impactful, or do you have any additional ideas to discuss? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-19-08 15:44:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:44:08 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23499
completion_tokens: 1
total_tokens: 23500
cost: $-1.000000


[2024-19-08 15:44:09 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

1

[2024-19-08 15:44:09 INFO] **[Seminar Conclusion]**:

 1

[2024-19-08 15:44:09 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-19-08 15:44:09 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-19-08 15:44:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    / ========== STATE VARIABLES ========== /\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    / ========== CONSTRUCTOR ========== /\n\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    / ========== ADMIN CONFIGURATION ========== /\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n\n    / ========== VIEWS ========== /\n\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    / ========== MUTATIVE FUNCTIONS ========== /\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n\n        if (total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    / ========== RESTRICTED FUNCTIONS ========== /\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n\n        emit RewardAdded(_rewardsToken, _reward);\n\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    / ========== MODIFIERS ========== /\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:44:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:44:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-19-08 15:44:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:44:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15308
completion_tokens: 982
total_tokens: 16290
cost: $-1.000000


[2024-19-08 15:44:24 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION:
The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to prevent reentrancy attacks. However, the `lock` function, which transfers tokens from the user to the contract, does not have this modifier applied to it. This could allow an attacker to call the `lock` function recursively before the state variables are updated, potentially leading to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION:
Ensure that the `lock` function is protected with the `nonReentrant` modifier to prevent reentrancy attacks. This will ensure that the function cannot be called again until the first invocation is completed.
```

### VULNERABILITY 2: Integer Overflow/Underflow
```
DETAILED DESCRIPTION:
Although the contract uses the `BoringMath` library, which provides safe math operations, there are still areas where integer overflow or underflow could occur, especially in calculations involving user balances and epoch supplies. If the library is not correctly implemented or if the Solidity version is not updated, this could lead to vulnerabilities.

RECOMMENDED MITIGATION:
Ensure that the latest version of Solidity is used (preferably 0.8.x or higher), which has built-in overflow and underflow checks. If using an older version, ensure that all arithmetic operations are wrapped in safe math functions from the `BoringMath` library.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION:
The contract allows the owner to add reward tokens and approve distributors. However, there is no mechanism to revoke these approvals or to check if the owner is acting maliciously. This could lead to a situation where the owner could drain funds or manipulate rewards.

RECOMMENDED MITIGATION:
Implement a mechanism to revoke approvals and consider using a multi-signature wallet for ownership to ensure that no single entity can control the contract entirely. Additionally, consider adding time-locks for critical functions to prevent immediate changes.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION:
Several functions, such as `setBoost`, `setStakeLimits`, and `addReward`, do not validate the input parameters thoroughly. For instance, setting a negative value for `maximumBoostPayment` or `boostRate` could lead to unexpected behavior.

RECOMMENDED MITIGATION:
Add input validation checks to ensure that all parameters are within acceptable ranges. For example, ensure that `maximumBoostPayment` and `boostRate` are non-negative and within predefined limits.
```

### VULNERABILITY 5: Potential for Denial of Service (DoS)
```
DETAILED DESCRIPTION:
The `shutdown` function allows the owner to withdraw all tokens and set the contract to a shutdown state. If an attacker gains control of the owner's account, they could call this function and effectively disable the contract, preventing users from accessing their funds.

RECOMMENDED MITIGATION:
Consider implementing a time-lock mechanism for the `shutdown` function or requiring multiple confirmations before executing such critical functions. This would help prevent a single point of failure and reduce the risk of a malicious shutdown.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION:
The contract makes external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`). If these external contracts are malicious or fail, it could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION:
Use the `call` method with proper error handling to ensure that any failure in external calls does not affect the state of the contract. Additionally, consider implementing checks to verify that external contracts are trusted and behave as expected.
```

### VULNERABILITY 7: Gas Limit Issues
```
DETAILED DESCRIPTION:
Functions that loop through arrays, such as `claimableRewards` and `lockedBalances`, could run into gas limit issues if the arrays grow too large. This could prevent users from executing these functions successfully.

RECOMMENDED MITIGATION:
Consider implementing pagination or limiting the number of entries processed in a single transaction. This would help ensure that users can always interact with the contract without hitting gas limits.
```

### VULNERABILITY 8: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION:
While some functions emit events, others do not, particularly those that change critical state variables (e.g., `setBoost`, `setStakeLimits`). This lack of transparency can make it difficult for users to track changes.

RECOMMENDED MITIGATION:
Ensure that all critical state changes emit appropriate events. This will enhance transparency and allow users to monitor contract activity more effectively.
```

<INFO> Analysis Complete.

[2024-19-08 15:44:24 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION:
The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to prevent reentrancy attacks. However, the `lock` function, which transfers tokens from the user to the contract, does not have this modifier applied to it. This could allow an attacker to call the `lock` function recursively before the state variables are updated, potentially leading to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION:
Ensure that the `lock` function is protected with the `nonReentrant` modifier to prevent reentrancy attacks. This will ensure that the function cannot be called again until the first invocation is completed.
```

### VULNERABILITY 2: Integer Overflow/Underflow
```
DETAILED DESCRIPTION:
Although the contract uses the `BoringMath` library, which provides safe math operations, there are still areas where integer overflow or underflow could occur, especially in calculations involving user balances and epoch supplies. If the library is not correctly implemented or if the Solidity version is not updated, this could lead to vulnerabilities.

RECOMMENDED MITIGATION:
Ensure that the latest version of Solidity is used (preferably 0.8.x or higher), which has built-in overflow and underflow checks. If using an older version, ensure that all arithmetic operations are wrapped in safe math functions from the `BoringMath` library.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION:
The contract allows the owner to add reward tokens and approve distributors. However, there is no mechanism to revoke these approvals or to check if the owner is acting maliciously. This could lead to a situation where the owner could drain funds or manipulate rewards.

RECOMMENDED MITIGATION:
Implement a mechanism to revoke approvals and consider using a multi-signature wallet for ownership to ensure that no single entity can control the contract entirely. Additionally, consider adding time-locks for critical functions to prevent immediate changes.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION:
Several functions, such as `setBoost`, `setStakeLimits`, and `addReward`, do not validate the input parameters thoroughly. For instance, setting a negative value for `maximumBoostPayment` or `boostRate` could lead to unexpected behavior.

RECOMMENDED MITIGATION:
Add input validation checks to ensure that all parameters are within acceptable ranges. For example, ensure that `maximumBoostPayment` and `boostRate` are non-negative and within predefined limits.
```

### VULNERABILITY 5: Potential for Denial of Service (DoS)
```
DETAILED DESCRIPTION:
The `shutdown` function allows the owner to withdraw all tokens and set the contract to a shutdown state. If an attacker gains control of the owner's account, they could call this function and effectively disable the contract, preventing users from accessing their funds.

RECOMMENDED MITIGATION:
Consider implementing a time-lock mechanism for the `shutdown` function or requiring multiple confirmations before executing such critical functions. This would help prevent a single point of failure and reduce the risk of a malicious shutdown.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION:
The contract makes external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`). If these external contracts are malicious or fail, it could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION:
Use the `call` method with proper error handling to ensure that any failure in external calls does not affect the state of the contract. Additionally, consider implementing checks to verify that external contracts are trusted and behave as expected.
```

### VULNERABILITY 7: Gas Limit Issues
```
DETAILED DESCRIPTION:
Functions that loop through arrays, such as `claimableRewards` and `lockedBalances`, could run into gas limit issues if the arrays grow too large. This could prevent users from executing these functions successfully.

RECOMMENDED MITIGATION:
Consider implementing pagination or limiting the number of entries processed in a single transaction. This would help ensure that users can always interact with the contract without hitting gas limits.
```

### VULNERABILITY 8: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION:
While some functions emit events, others do not, particularly those that change critical state variables (e.g., `setBoost`, `setStakeLimits`). This lack of transparency can make it difficult for users to track changes.

RECOMMENDED MITIGATION:
Ensure that all critical state changes emit appropriate events. This will enhance transparency and allow users to monitor contract activity more effectively.
```

<INFO> Analysis Complete.

[2024-19-08 15:44:24 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-19-08 15:44:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:44:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:44:24 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-19-08 15:44:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:44:34 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7713
completion_tokens: 759
total_tokens: 8472
cost: $-1.000000


[2024-19-08 15:44:34 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

### Summary of Security Vulnerabilities in the CvxLocker Contract

1. **Reentrancy Vulnerability**: 
   - The contract uses the `nonReentrant` modifier to protect against reentrancy attacks; however, there are areas where state changes occur after external calls (e.g., transferring tokens). This could potentially allow for reentrancy if not properly managed in all functions.

2. **Lack of Input Validation**:
   - Several functions do not adequately validate input parameters. For example, the `setBoost` function does not check if the `_rate` is within a reasonable range relative to the `_max` value, which could lead to unexpected behavior.

3. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, the use of custom math libraries (like `BoringMath`) could introduce vulnerabilities if not thoroughly audited. There is a reliance on external libraries that may not be well-tested.

4. **Improper Access Control**:
   - The `approveRewardDistributor` function allows any address to approve reward distributors, which could lead to unauthorized access if not properly managed. The contract should ensure that only trusted addresses can be approved.

5. **Potential for Denial of Service (DoS)**:
   - The `shutdown` function allows the owner to shut down the contract, which could lead to a denial of service for users who are unable to withdraw their funds. This could be exploited if the owner acts maliciously.

6. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `claimableRewards`, `lockedBalances`, etc.) could run into gas limit issues if the number of rewards or locks becomes large, potentially leading to failed transactions.

7. **Unprotected State Changes**:
   - Certain state variables are modified without adequate checks or protections, such as `lockedSupply` and `boostedSupply`. This could lead to inconsistencies in the contract's state if not properly managed.

8. **Lack of Event Emission**:
   - Some critical state-changing functions do not emit events, which can hinder tracking and auditing of contract activity. For example, the `setStakeLimits` function should emit an event to log changes.

### Comprehensive Analysis Report

The CvxLocker contract, while implementing several best practices such as using the `nonReentrant` modifier and OpenZeppelin's libraries, still presents multiple security vulnerabilities that could be exploited by malicious actors. The identified vulnerabilities range from reentrancy risks to improper access control and potential denial of service scenarios.

To mitigate these risks, the following recommendations are proposed:

- **Enhance Input Validation**: Implement stricter checks on input parameters across all functions to prevent unexpected behavior and ensure that values fall within acceptable ranges.
  
- **Review External Libraries**: Conduct a thorough audit of any external libraries used, such as `BoringMath`, to ensure they are secure and do not introduce vulnerabilities.

- **Implement Robust Access Control**: Ensure that functions that modify critical state variables or approve addresses have proper access control mechanisms in place to prevent unauthorized access.

- **Optimize Gas Usage**: Consider optimizing functions that iterate over arrays to prevent gas limit issues, potentially by implementing pagination or limiting the number of iterations.

- **Emit Events for Critical Changes**: Ensure that all state-changing functions emit appropriate events to facilitate better tracking and auditing of contract activity.

- **Regular Security Audits**: Conduct regular security audits and testing, especially after any updates or changes to the contract, to identify and address new vulnerabilities.

By addressing these vulnerabilities and implementing the recommended changes, the security posture of the CvxLocker contract can be significantly improved, thereby enhancing user trust and contract reliability.

[2024-19-08 15:44:34 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the CvxLocker Contract

1. **Reentrancy Vulnerability**: 
   - The contract uses the `nonReentrant` modifier to protect against reentrancy attacks; however, there are areas where state changes occur after external calls (e.g., transferring tokens). This could potentially allow for reentrancy if not properly managed in all functions.

2. **Lack of Input Validation**:
   - Several functions do not adequately validate input parameters. For example, the `setBoost` function does not check if the `_rate` is within a reasonable range relative to the `_max` value, which could lead to unexpected behavior.

3. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, the use of custom math libraries (like `BoringMath`) could introduce vulnerabilities if not thoroughly audited. There is a reliance on external libraries that may not be well-tested.

4. **Improper Access Control**:
   - The `approveRewardDistributor` function allows any address to approve reward distributors, which could lead to unauthorized access if not properly managed. The contract should ensure that only trusted addresses can be approved.

5. **Potential for Denial of Service (DoS)**:
   - The `shutdown` function allows the owner to shut down the contract, which could lead to a denial of service for users who are unable to withdraw their funds. This could be exploited if the owner acts maliciously.

6. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `claimableRewards`, `lockedBalances`, etc.) could run into gas limit issues if the number of rewards or locks becomes large, potentially leading to failed transactions.

7. **Unprotected State Changes**:
   - Certain state variables are modified without adequate checks or protections, such as `lockedSupply` and `boostedSupply`. This could lead to inconsistencies in the contract's state if not properly managed.

8. **Lack of Event Emission**:
   - Some critical state-changing functions do not emit events, which can hinder tracking and auditing of contract activity. For example, the `setStakeLimits` function should emit an event to log changes.

### Comprehensive Analysis Report

The CvxLocker contract, while implementing several best practices such as using the `nonReentrant` modifier and OpenZeppelin's libraries, still presents multiple security vulnerabilities that could be exploited by malicious actors. The identified vulnerabilities range from reentrancy risks to improper access control and potential denial of service scenarios.

To mitigate these risks, the following recommendations are proposed:

- **Enhance Input Validation**: Implement stricter checks on input parameters across all functions to prevent unexpected behavior and ensure that values fall within acceptable ranges.
  
- **Review External Libraries**: Conduct a thorough audit of any external libraries used, such as `BoringMath`, to ensure they are secure and do not introduce vulnerabilities.

- **Implement Robust Access Control**: Ensure that functions that modify critical state variables or approve addresses have proper access control mechanisms in place to prevent unauthorized access.

- **Optimize Gas Usage**: Consider optimizing functions that iterate over arrays to prevent gas limit issues, potentially by implementing pagination or limiting the number of iterations.

- **Emit Events for Critical Changes**: Ensure that all state-changing functions emit appropriate events to facilitate better tracking and auditing of contract activity.

- **Regular Security Audits**: Conduct regular security audits and testing, especially after any updates or changes to the contract, to identify and address new vulnerabilities.

By addressing these vulnerabilities and implementing the recommended changes, the security posture of the CvxLocker contract can be significantly improved, thereby enhancing user trust and contract reliability.

[2024-19-08 15:44:34 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-19-08 15:44:34 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    / ========== STATE VARIABLES ========== /\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    / ========== CONSTRUCTOR ========== /\n\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    / ========== ADMIN CONFIGURATION ========== /\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n\n    / ========== VIEWS ========== /\n\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    / ========== MUTATIVE FUNCTIONS ========== /\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n\n        if (total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    / ========== RESTRICTED FUNCTIONS ========== /\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n\n        emit RewardAdded(_rewardsToken, _reward);\n\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    / ========== MODIFIERS ========== /\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:44:34 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:44:34 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-19-08 15:44:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:44:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15308
completion_tokens: 1037
total_tokens: 16345
cost: $-1.000000


[2024-19-08 15:44:49 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

### VULNERABILITY: Reentrancy Attack
```
The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract, which is a good practice to prevent reentrancy attacks. However, there are still areas where reentrancy could potentially be exploited, particularly in functions that involve transferring tokens or calling external contracts (e.g., `transferCVX`, `getReward`, and `_processExpiredLocks`). 

If an external contract is called that can re-enter the `CvxLocker` contract, it could manipulate the state before the initial call completes, leading to unexpected behavior or loss of funds.

**Mitigation:** 
- Ensure that all state changes are made before calling external contracts or transferring tokens. This can be achieved by reordering the code to update balances and states before any external calls.
```

### VULNERABILITY: Integer Overflow/Underflow
```
Although the contract uses the `BoringMath` library, which provides safe math functions, there are still areas where integer overflow or underflow could occur, especially in calculations that involve user inputs or external data.

For example, in the `_lock` function, the calculation of `boostedAmount` could potentially lead to an overflow if the input `_amount` is large enough.

**Mitigation:** 
- Use the latest version of Solidity (0.8.x or above) which has built-in overflow/underflow checks. Alternatively, ensure that all arithmetic operations are performed using safe math functions.
```

### VULNERABILITY: Improper Access Control
```
The `approveRewardDistributor` function allows the owner to approve or disapprove reward distributors. If the owners private key is compromised, an attacker could manipulate reward distributions.

Additionally, the `shutdown` function can be called by the owner to withdraw all tokens, which could lead to a complete loss of user funds if the owner acts maliciously.

**Mitigation:** 
- Implement a multi-signature wallet for ownership functions to ensure that critical actions require multiple approvals. This adds a layer of security against single-point failures.
```

### VULNERABILITY: Lack of Input Validation
```
In several functions, such as `setBoost`, `setStakeLimits`, and `addReward`, there is insufficient validation of input parameters. For instance, the `_max` and `_rate` parameters in `setBoost` should be validated against realistic limits to prevent abuse.

**Mitigation:** 
- Implement stricter checks on input parameters to ensure they fall within acceptable ranges. For example, ensure that `_max` is not excessively high or that `_rate` does not exceed a certain threshold.
```

### VULNERABILITY: Potential for Token Loss
```
In the `recoverERC20` function, the contract allows the owner to recover tokens, but it does not check if the token being recovered is a reward token or the staking token. This could lead to accidental loss of tokens that are meant to be used within the contract.

**Mitigation:** 
- Add checks to ensure that the token being recovered is not one of the tokens that are actively used in the contract (e.g., `stakingToken` or any token in `rewardTokens`).
```

### VULNERABILITY: Shutdown Functionality Risks
```
The `shutdown` function allows the owner to withdraw all tokens and set the contract to a shutdown state. If this function is called, users will not be able to interact with the contract anymore, which could be exploited by a malicious owner.

**Mitigation:** 
- Consider implementing a time-lock mechanism for the shutdown function, where the owner must wait a certain period before the shutdown takes effect. This gives users time to react if they notice suspicious activity.
```

### VULNERABILITY: Gas Limit Issues
```
In functions that involve looping through arrays, such as `claimableRewards` and `lockedBalances`, there is a risk of hitting the block gas limit if the number of users or rewards grows significantly.

**Mitigation:** 
- Implement pagination or limit the number of iterations to avoid exceeding gas limits. This can be done by allowing users to query their rewards in smaller batches.
```

### VULNERABILITY: Unchecked External Calls
```
In the `notifyRewardAmount` function, the contract calls `safeTransferFrom` without checking if the transfer was successful. If the token contract does not return a boolean value, it could lead to unexpected behavior.

**Mitigation:** 
- Ensure that all external calls are checked for success, or use the `SafeERC20` library which handles this internally.
```

### VULNERABILITY: Epoch Management Risks
```
The management of epochs relies on timestamps and can be manipulated if the block timestamps are not reliable. If an attacker can manipulate the block timestamp, they could potentially exploit the epoch system to gain rewards unfairly.

**Mitigation:** 
- Consider using a more robust mechanism for epoch management that does not solely rely on block timestamps, or implement checks to ensure that timestamps are within a reasonable range.
```

<INFO> Analysis Complete.

[2024-19-08 15:44:49 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract, which is a good practice to prevent reentrancy attacks. However, there are still areas where reentrancy could potentially be exploited, particularly in functions that involve transferring tokens or calling external contracts (e.g., `transferCVX`, `getReward`, and `_processExpiredLocks`). 

If an external contract is called that can re-enter the `CvxLocker` contract, it could manipulate the state before the initial call completes, leading to unexpected behavior or loss of funds.

**Mitigation:** 
- Ensure that all state changes are made before calling external contracts or transferring tokens. This can be achieved by reordering the code to update balances and states before any external calls.
```

### VULNERABILITY: Integer Overflow/Underflow
```
Although the contract uses the `BoringMath` library, which provides safe math functions, there are still areas where integer overflow or underflow could occur, especially in calculations that involve user inputs or external data.

For example, in the `_lock` function, the calculation of `boostedAmount` could potentially lead to an overflow if the input `_amount` is large enough.

**Mitigation:** 
- Use the latest version of Solidity (0.8.x or above) which has built-in overflow/underflow checks. Alternatively, ensure that all arithmetic operations are performed using safe math functions.
```

### VULNERABILITY: Improper Access Control
```
The `approveRewardDistributor` function allows the owner to approve or disapprove reward distributors. If the owners private key is compromised, an attacker could manipulate reward distributions.

Additionally, the `shutdown` function can be called by the owner to withdraw all tokens, which could lead to a complete loss of user funds if the owner acts maliciously.

**Mitigation:** 
- Implement a multi-signature wallet for ownership functions to ensure that critical actions require multiple approvals. This adds a layer of security against single-point failures.
```

### VULNERABILITY: Lack of Input Validation
```
In several functions, such as `setBoost`, `setStakeLimits`, and `addReward`, there is insufficient validation of input parameters. For instance, the `_max` and `_rate` parameters in `setBoost` should be validated against realistic limits to prevent abuse.

**Mitigation:** 
- Implement stricter checks on input parameters to ensure they fall within acceptable ranges. For example, ensure that `_max` is not excessively high or that `_rate` does not exceed a certain threshold.
```

### VULNERABILITY: Potential for Token Loss
```
In the `recoverERC20` function, the contract allows the owner to recover tokens, but it does not check if the token being recovered is a reward token or the staking token. This could lead to accidental loss of tokens that are meant to be used within the contract.

**Mitigation:** 
- Add checks to ensure that the token being recovered is not one of the tokens that are actively used in the contract (e.g., `stakingToken` or any token in `rewardTokens`).
```

### VULNERABILITY: Shutdown Functionality Risks
```
The `shutdown` function allows the owner to withdraw all tokens and set the contract to a shutdown state. If this function is called, users will not be able to interact with the contract anymore, which could be exploited by a malicious owner.

**Mitigation:** 
- Consider implementing a time-lock mechanism for the shutdown function, where the owner must wait a certain period before the shutdown takes effect. This gives users time to react if they notice suspicious activity.
```

### VULNERABILITY: Gas Limit Issues
```
In functions that involve looping through arrays, such as `claimableRewards` and `lockedBalances`, there is a risk of hitting the block gas limit if the number of users or rewards grows significantly.

**Mitigation:** 
- Implement pagination or limit the number of iterations to avoid exceeding gas limits. This can be done by allowing users to query their rewards in smaller batches.
```

### VULNERABILITY: Unchecked External Calls
```
In the `notifyRewardAmount` function, the contract calls `safeTransferFrom` without checking if the transfer was successful. If the token contract does not return a boolean value, it could lead to unexpected behavior.

**Mitigation:** 
- Ensure that all external calls are checked for success, or use the `SafeERC20` library which handles this internally.
```

### VULNERABILITY: Epoch Management Risks
```
The management of epochs relies on timestamps and can be manipulated if the block timestamps are not reliable. If an attacker can manipulate the block timestamp, they could potentially exploit the epoch system to gain rewards unfairly.

**Mitigation:** 
- Consider using a more robust mechanism for epoch management that does not solely rely on block timestamps, or implement checks to ensure that timestamps are within a reasonable range.
```

<INFO> Analysis Complete.

[2024-19-08 15:44:49 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-19-08 15:44:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:44:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:44:49 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-19-08 15:45:02 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:45:02 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7713
completion_tokens: 888
total_tokens: 8601
cost: $-1.000000


[2024-19-08 15:45:02 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

### Summary of Security Vulnerabilities in the CvxLocker Contract

1. **Reentrancy Vulnerability**: 
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks, but there are still functions that could potentially allow for reentrancy if not properly managed, especially in functions that involve external calls like `transferCVX` and `getReward`.

2. **Arithmetic Issues**:
   - The contract uses the `BoringMath` library for safe arithmetic operations, which is good practice. However, there are still areas where unchecked arithmetic could lead to overflows or underflows, particularly in calculations involving user balances and epoch supplies.

3. **Access Control**:
   - The contract relies on the `onlyOwner` modifier for critical functions, which could be a single point of failure. If the owner's private key is compromised, an attacker could manipulate the contract's state.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `claimableRewards`, `lockedBalances`, and `balanceAtEpochOf`) could run into gas limit issues if the number of rewards or locks grows significantly. This could lead to denial of service if users cannot execute these functions due to gas constraints.

5. **Improper Handling of External Calls**:
   - The contract makes external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`). If these contracts are malicious or have vulnerabilities, they could exploit the CvxLocker contract.

6. **Lack of Input Validation**:
   - Some functions do not adequately validate input parameters. For example, in `setStakeLimits`, the contract does not check if `_minimum` is less than or equal to `_maximum`, which could lead to unexpected behavior.

7. **Potential for Front-Running**:
   - The contract does not implement mechanisms to prevent front-running attacks, especially in functions that involve staking and locking tokens. An attacker could exploit the timing of transactions to gain an unfair advantage.

8. **Shutdown Mechanism**:
   - The `shutdown` function allows the owner to halt all operations, which could be misused if the owner's account is compromised. There is no mechanism for recovery or for users to withdraw their funds in a secure manner.

### Comprehensive Analysis Report

The CvxLocker contract is a complex smart contract designed for locking CVX tokens and distributing rewards. While it incorporates several best practices, such as using the `nonReentrant` modifier and the `BoringMath` library for safe arithmetic, it still presents multiple security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Although the contract uses the `nonReentrant` modifier, careful attention must be paid to external calls that could still be exploited if not managed correctly.

2. **Arithmetic Safety**: The reliance on safe math is commendable, but developers should ensure that all arithmetic operations are adequately safeguarded against potential overflows and underflows.

3. **Access Control Risks**: The single owner model poses a risk, as any compromise of the owner's private key could lead to malicious actions. Implementing a multi-signature wallet or a time-lock mechanism could enhance security.

4. **Gas Limit Concerns**: Functions that involve loops over potentially large arrays could lead to gas limit issues, making them unusable under certain conditions. Optimizing these functions or implementing pagination could mitigate this risk.

5. **External Call Vulnerabilities**: The contract's interaction with external contracts introduces risks. Developers should ensure that these contracts are audited and trustworthy.

6. **Input Validation**: Functions should include comprehensive input validation to prevent unexpected behavior and ensure that parameters are within acceptable ranges.

7. **Front-Running Risks**: The absence of mechanisms to prevent front-running could lead to exploitation. Implementing measures such as commit-reveal schemes could help mitigate this risk.

8. **Shutdown Mechanism**: The ability for the owner to shut down the contract poses risks. A more robust mechanism for handling emergencies or contract upgrades should be considered.

In conclusion, while the CvxLocker contract has been designed with several security features, it is essential to address the identified vulnerabilities to enhance its robustness. A thorough audit and testing phase, along with the implementation of best practices in smart contract development, will be crucial in ensuring the security and reliability of the contract.

[2024-19-08 15:45:02 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the CvxLocker Contract

1. **Reentrancy Vulnerability**: 
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks, but there are still functions that could potentially allow for reentrancy if not properly managed, especially in functions that involve external calls like `transferCVX` and `getReward`.

2. **Arithmetic Issues**:
   - The contract uses the `BoringMath` library for safe arithmetic operations, which is good practice. However, there are still areas where unchecked arithmetic could lead to overflows or underflows, particularly in calculations involving user balances and epoch supplies.

3. **Access Control**:
   - The contract relies on the `onlyOwner` modifier for critical functions, which could be a single point of failure. If the owner's private key is compromised, an attacker could manipulate the contract's state.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `claimableRewards`, `lockedBalances`, and `balanceAtEpochOf`) could run into gas limit issues if the number of rewards or locks grows significantly. This could lead to denial of service if users cannot execute these functions due to gas constraints.

5. **Improper Handling of External Calls**:
   - The contract makes external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`). If these contracts are malicious or have vulnerabilities, they could exploit the CvxLocker contract.

6. **Lack of Input Validation**:
   - Some functions do not adequately validate input parameters. For example, in `setStakeLimits`, the contract does not check if `_minimum` is less than or equal to `_maximum`, which could lead to unexpected behavior.

7. **Potential for Front-Running**:
   - The contract does not implement mechanisms to prevent front-running attacks, especially in functions that involve staking and locking tokens. An attacker could exploit the timing of transactions to gain an unfair advantage.

8. **Shutdown Mechanism**:
   - The `shutdown` function allows the owner to halt all operations, which could be misused if the owner's account is compromised. There is no mechanism for recovery or for users to withdraw their funds in a secure manner.

### Comprehensive Analysis Report

The CvxLocker contract is a complex smart contract designed for locking CVX tokens and distributing rewards. While it incorporates several best practices, such as using the `nonReentrant` modifier and the `BoringMath` library for safe arithmetic, it still presents multiple security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Although the contract uses the `nonReentrant` modifier, careful attention must be paid to external calls that could still be exploited if not managed correctly.

2. **Arithmetic Safety**: The reliance on safe math is commendable, but developers should ensure that all arithmetic operations are adequately safeguarded against potential overflows and underflows.

3. **Access Control Risks**: The single owner model poses a risk, as any compromise of the owner's private key could lead to malicious actions. Implementing a multi-signature wallet or a time-lock mechanism could enhance security.

4. **Gas Limit Concerns**: Functions that involve loops over potentially large arrays could lead to gas limit issues, making them unusable under certain conditions. Optimizing these functions or implementing pagination could mitigate this risk.

5. **External Call Vulnerabilities**: The contract's interaction with external contracts introduces risks. Developers should ensure that these contracts are audited and trustworthy.

6. **Input Validation**: Functions should include comprehensive input validation to prevent unexpected behavior and ensure that parameters are within acceptable ranges.

7. **Front-Running Risks**: The absence of mechanisms to prevent front-running could lead to exploitation. Implementing measures such as commit-reveal schemes could help mitigate this risk.

8. **Shutdown Mechanism**: The ability for the owner to shut down the contract poses risks. A more robust mechanism for handling emergencies or contract upgrades should be considered.

In conclusion, while the CvxLocker contract has been designed with several security features, it is essential to address the identified vulnerabilities to enhance its robustness. A thorough audit and testing phase, along with the implementation of best practices in smart contract development, will be crucial in ensuring the security and reliability of the contract.

[2024-19-08 15:45:02 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-19-08 15:45:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    / ========== STATE VARIABLES ========== /\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    / ========== CONSTRUCTOR ========== /\n\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    / ========== ADMIN CONFIGURATION ========== /\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n\n    / ========== VIEWS ========== /\n\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    / ========== MUTATIVE FUNCTIONS ========== /\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n\n        if (total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    / ========== RESTRICTED FUNCTIONS ========== /\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n\n        emit RewardAdded(_rewardsToken, _reward);\n\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    / ========== MODIFIERS ========== /\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:45:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:45:02 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-19-08 15:45:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:45:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15308
completion_tokens: 977
total_tokens: 16285
cost: $-1.000000


[2024-19-08 15:45:19 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract, which is a good practice to prevent reentrancy attacks. However, there are still functions, such as `transferCVX`, that could potentially be exploited if not properly guarded. If an external call is made (like transferring tokens), it could allow a malicious contract to re-enter the function before the state changes are completed.

RECOMMENDED MITIGATION: Ensure that all external calls are made at the end of the function after all state changes have been made. For example, in the `processExpiredLocks` function, the call to `transferCVX` should be made after updating the user's balances and total supplies.
```

### VULNERABILITY 2: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: The contract uses Solidity version 0.6.12, which has built-in overflow and underflow checks. However, the use of custom math libraries (like BoringMath) could potentially introduce vulnerabilities if not properly implemented. If any of these functions do not handle edge cases correctly, it could lead to unexpected behavior.

RECOMMENDED MITIGATION: Review the implementation of the BoringMath library to ensure that all arithmetic operations are safe. Consider using OpenZeppelin's SafeMath library for additional safety, or ensure that the custom library is thoroughly tested and audited.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The contract allows the owner to perform critical operations such as adding reward tokens, setting staking limits, and shutting down the contract. If the owner's private key is compromised, an attacker could take control of the contract and perform malicious actions.

RECOMMENDED MITIGATION: Implement a multi-signature wallet for critical administrative functions to reduce the risk of a single point of failure. Additionally, consider implementing time-lock mechanisms for sensitive operations to provide a buffer period for stakeholders to react to any unauthorized changes.
```

### VULNERABILITY 4: Gas Limit and Loops
```
DETAILED DESCRIPTION: Functions like `claimableRewards`, `lockedBalances`, and `processExpiredLocks` contain loops that iterate over potentially large arrays (e.g., `userLocks`). If the number of locks grows significantly, this could lead to exceeding the gas limit, causing transactions to fail.

RECOMMENDED MITIGATION: Optimize the logic to minimize the number of iterations or consider using pagination for large datasets. Additionally, implement checks to limit the maximum number of locks a user can have, or provide a mechanism to batch process rewards or locks.
```

### VULNERABILITY 5: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions such as `setBoost`, `setStakeLimits`, and `addReward` do not validate the input values thoroughly. For instance, setting a negative value or an excessively large value could lead to unexpected behavior.

RECOMMENDED MITIGATION: Implement stricter input validation checks to ensure that all parameters are within acceptable ranges. For example, ensure that stake limits are positive and that reward amounts are reasonable.
```

### VULNERABILITY 6: Shutdown Functionality
```
DETAILED DESCRIPTION: The `shutdown` function allows the owner to withdraw all tokens and set the contract to a shutdown state. If this function is called maliciously or accidentally, it could lock users out of their funds.

RECOMMENDED MITIGATION: Implement a time-lock mechanism for the shutdown function, allowing users to withdraw their funds before the contract is permanently shut down. Additionally, consider requiring a multi-signature approval for the shutdown action.
```

### VULNERABILITY 7: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`) without checking the return values. If these calls fail, it could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. Consider using the `require` statement to ensure that external calls succeed before proceeding with further logic.
```

### VULNERABILITY 8: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract allows users to lock tokens and process expired locks, which could be susceptible to front-running attacks. An attacker could observe pending transactions and submit their own transactions with higher gas prices to gain an advantage.

RECOMMENDED MITIGATION: Implement mechanisms to mitigate front-running, such as using commit-reveal schemes or time-based locks for sensitive operations. Additionally, consider using a decentralized oracle for critical state changes to reduce predictability.
```

<INFO> Analysis Complete.

[2024-19-08 15:45:19 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract, which is a good practice to prevent reentrancy attacks. However, there are still functions, such as `transferCVX`, that could potentially be exploited if not properly guarded. If an external call is made (like transferring tokens), it could allow a malicious contract to re-enter the function before the state changes are completed.

RECOMMENDED MITIGATION: Ensure that all external calls are made at the end of the function after all state changes have been made. For example, in the `processExpiredLocks` function, the call to `transferCVX` should be made after updating the user's balances and total supplies.
```

### VULNERABILITY 2: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: The contract uses Solidity version 0.6.12, which has built-in overflow and underflow checks. However, the use of custom math libraries (like BoringMath) could potentially introduce vulnerabilities if not properly implemented. If any of these functions do not handle edge cases correctly, it could lead to unexpected behavior.

RECOMMENDED MITIGATION: Review the implementation of the BoringMath library to ensure that all arithmetic operations are safe. Consider using OpenZeppelin's SafeMath library for additional safety, or ensure that the custom library is thoroughly tested and audited.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The contract allows the owner to perform critical operations such as adding reward tokens, setting staking limits, and shutting down the contract. If the owner's private key is compromised, an attacker could take control of the contract and perform malicious actions.

RECOMMENDED MITIGATION: Implement a multi-signature wallet for critical administrative functions to reduce the risk of a single point of failure. Additionally, consider implementing time-lock mechanisms for sensitive operations to provide a buffer period for stakeholders to react to any unauthorized changes.
```

### VULNERABILITY 4: Gas Limit and Loops
```
DETAILED DESCRIPTION: Functions like `claimableRewards`, `lockedBalances`, and `processExpiredLocks` contain loops that iterate over potentially large arrays (e.g., `userLocks`). If the number of locks grows significantly, this could lead to exceeding the gas limit, causing transactions to fail.

RECOMMENDED MITIGATION: Optimize the logic to minimize the number of iterations or consider using pagination for large datasets. Additionally, implement checks to limit the maximum number of locks a user can have, or provide a mechanism to batch process rewards or locks.
```

### VULNERABILITY 5: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions such as `setBoost`, `setStakeLimits`, and `addReward` do not validate the input values thoroughly. For instance, setting a negative value or an excessively large value could lead to unexpected behavior.

RECOMMENDED MITIGATION: Implement stricter input validation checks to ensure that all parameters are within acceptable ranges. For example, ensure that stake limits are positive and that reward amounts are reasonable.
```

### VULNERABILITY 6: Shutdown Functionality
```
DETAILED DESCRIPTION: The `shutdown` function allows the owner to withdraw all tokens and set the contract to a shutdown state. If this function is called maliciously or accidentally, it could lock users out of their funds.

RECOMMENDED MITIGATION: Implement a time-lock mechanism for the shutdown function, allowing users to withdraw their funds before the contract is permanently shut down. Additionally, consider requiring a multi-signature approval for the shutdown action.
```

### VULNERABILITY 7: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`) without checking the return values. If these calls fail, it could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. Consider using the `require` statement to ensure that external calls succeed before proceeding with further logic.
```

### VULNERABILITY 8: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract allows users to lock tokens and process expired locks, which could be susceptible to front-running attacks. An attacker could observe pending transactions and submit their own transactions with higher gas prices to gain an advantage.

RECOMMENDED MITIGATION: Implement mechanisms to mitigate front-running, such as using commit-reveal schemes or time-based locks for sensitive operations. Additionally, consider using a decentralized oracle for critical state changes to reduce predictability.
```

<INFO> Analysis Complete.

[2024-19-08 15:45:19 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-19-08 15:45:19 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-19-08 15:45:19 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:45:19 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-19-08 15:45:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:45:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7713
completion_tokens: 921
total_tokens: 8634
cost: $-1.000000


[2024-19-08 15:45:31 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

### Summary of Security Vulnerabilities in CvxLocker Contract

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier, which is a good practice to prevent reentrancy attacks. However, there are several functions that could potentially be exploited if not properly managed, especially in functions that involve external calls (e.g., `transferCVX`, `getReward`, and `processExpiredLocks`). Careful attention must be paid to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The contract relies heavily on the `onlyOwner` modifier for critical functions. If the owner's private key is compromised, an attacker could manipulate the contract's state, including adding or approving reward distributors, changing staking limits, or shutting down the contract.

3. **Arithmetic Vulnerabilities**:
   - Although the contract uses `BoringMath` for safe arithmetic operations, there are still areas where integer overflows or underflows could occur if not properly handled. For instance, in the `_lock` and `_processExpiredLocks` functions, care must be taken to ensure that calculations do not exceed the limits of the data types used.

4. **Gas Limit and Loops**:
   - Functions that involve loops, such as `claimableRewards`, `balanceAtEpochOf`, and `lockedBalances`, could potentially run into gas limit issues if the number of reward tokens or locks becomes large. This could lead to failed transactions or denial of service.

5. **Improper Handling of External Calls**:
   - The contract makes several external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`). If these contracts are malicious or have vulnerabilities, they could affect the security of the `CvxLocker` contract. It is crucial to ensure that these external contracts are audited and trusted.

6. **Shutdown Functionality**:
   - The `shutdown` function allows the owner to withdraw all tokens and stop the contract. If misused, this could lead to a complete loss of funds for users. The conditions under which this function can be called should be carefully considered.

7. **Reward Distribution Logic**:
   - The logic for reward distribution could be manipulated if the reward distributors are not properly managed. If an unauthorized address is approved as a distributor, it could lead to the misallocation of rewards.

8. **Lack of Event Emission for Critical State Changes**:
   - While the contract emits events for some actions, there are critical state changes (e.g., when rewards are added or when the contract is shut down) that may not emit events. This could hinder transparency and tracking of contract activity.

### Comprehensive Analysis Report

The `CvxLocker` contract is a complex smart contract designed for locking CVX tokens and distributing rewards. While it incorporates several best practices, including the use of the `nonReentrant` modifier and safe math libraries, there are notable vulnerabilities that need to be addressed to enhance its security.

1. **Reentrancy Protection**: The use of the `nonReentrant` modifier is commendable, but developers must ensure that all state changes occur before any external calls to mitigate potential reentrancy attacks.

2. **Access Control**: The reliance on the owner for critical functions poses a risk. Implementing a multi-signature wallet or a time-lock mechanism could enhance security.

3. **Arithmetic Safety**: Although the contract uses safe math, developers should remain vigilant about potential overflows and underflows, especially in complex calculations.

4. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, especially as the number of users and reward tokens increases.

5. **External Dependencies**: The contract's reliance on external contracts necessitates thorough audits of those contracts to ensure they do not introduce vulnerabilities.

6. **Shutdown Risks**: The shutdown functionality should be carefully controlled, with clear guidelines on when and how it can be invoked to prevent misuse.

7. **Reward Management**: Proper management of reward distributors is crucial to prevent unauthorized access to reward distribution.

8. **Event Emission**: Enhancing event logging for critical state changes will improve transparency and allow for better tracking of contract activity.

In conclusion, while the `CvxLocker` contract has a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough audit, including testing against known attack vectors, is recommended before deployment to ensure the safety of user funds and the integrity of the contract's operations.

[2024-19-08 15:45:31 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in CvxLocker Contract

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier, which is a good practice to prevent reentrancy attacks. However, there are several functions that could potentially be exploited if not properly managed, especially in functions that involve external calls (e.g., `transferCVX`, `getReward`, and `processExpiredLocks`). Careful attention must be paid to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The contract relies heavily on the `onlyOwner` modifier for critical functions. If the owner's private key is compromised, an attacker could manipulate the contract's state, including adding or approving reward distributors, changing staking limits, or shutting down the contract.

3. **Arithmetic Vulnerabilities**:
   - Although the contract uses `BoringMath` for safe arithmetic operations, there are still areas where integer overflows or underflows could occur if not properly handled. For instance, in the `_lock` and `_processExpiredLocks` functions, care must be taken to ensure that calculations do not exceed the limits of the data types used.

4. **Gas Limit and Loops**:
   - Functions that involve loops, such as `claimableRewards`, `balanceAtEpochOf`, and `lockedBalances`, could potentially run into gas limit issues if the number of reward tokens or locks becomes large. This could lead to failed transactions or denial of service.

5. **Improper Handling of External Calls**:
   - The contract makes several external calls to other contracts (e.g., `IStakingProxy`, `IRewardStaking`). If these contracts are malicious or have vulnerabilities, they could affect the security of the `CvxLocker` contract. It is crucial to ensure that these external contracts are audited and trusted.

6. **Shutdown Functionality**:
   - The `shutdown` function allows the owner to withdraw all tokens and stop the contract. If misused, this could lead to a complete loss of funds for users. The conditions under which this function can be called should be carefully considered.

7. **Reward Distribution Logic**:
   - The logic for reward distribution could be manipulated if the reward distributors are not properly managed. If an unauthorized address is approved as a distributor, it could lead to the misallocation of rewards.

8. **Lack of Event Emission for Critical State Changes**:
   - While the contract emits events for some actions, there are critical state changes (e.g., when rewards are added or when the contract is shut down) that may not emit events. This could hinder transparency and tracking of contract activity.

### Comprehensive Analysis Report

The `CvxLocker` contract is a complex smart contract designed for locking CVX tokens and distributing rewards. While it incorporates several best practices, including the use of the `nonReentrant` modifier and safe math libraries, there are notable vulnerabilities that need to be addressed to enhance its security.

1. **Reentrancy Protection**: The use of the `nonReentrant` modifier is commendable, but developers must ensure that all state changes occur before any external calls to mitigate potential reentrancy attacks.

2. **Access Control**: The reliance on the owner for critical functions poses a risk. Implementing a multi-signature wallet or a time-lock mechanism could enhance security.

3. **Arithmetic Safety**: Although the contract uses safe math, developers should remain vigilant about potential overflows and underflows, especially in complex calculations.

4. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, especially as the number of users and reward tokens increases.

5. **External Dependencies**: The contract's reliance on external contracts necessitates thorough audits of those contracts to ensure they do not introduce vulnerabilities.

6. **Shutdown Risks**: The shutdown functionality should be carefully controlled, with clear guidelines on when and how it can be invoked to prevent misuse.

7. **Reward Management**: Proper management of reward distributors is crucial to prevent unauthorized access to reward distribution.

8. **Event Emission**: Enhancing event logging for critical state changes will improve transparency and allow for better tracking of contract activity.

In conclusion, while the `CvxLocker` contract has a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough audit, including testing against known attack vectors, is recommended before deployment to ensure the safety of user funds and the integrity of the contract's operations.

[2024-19-08 15:45:34 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport "../../interfaces/cvx/MathUtil.sol";\nimport "../../interfaces/cvx/IStakingProxy.sol";\nimport "../../interfaces/cvx/IRewardStaking.sol";\nimport "../../interfaces/cvx/BoringMath.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\nimport "@openzeppelin/contracts/math/Math.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\n// CVX Locking contract for https://www.convexfinance.com/\n// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform\n// Based on EPS Staking contract for http://ellipsis.finance/\n// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\ncontract CvxLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    / ========== STATE VARIABLES ========== /\n\n    struct Reward {\n        bool useBoost;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n    }\n    struct Balances {\n        uint112 locked;\n        uint112 boosted;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint112 boosted;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply; //epoch boosted supply\n        uint32 date; //epoch start date\n    }\n\n    //token constants\n    IERC20 public constant stakingToken =\n        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx\n    address public constant cvxCrv =\n        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address =&gt; Reward) public rewardData;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // reward token -&gt; distributor -&gt; is approved to add rewards\n    mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;\n\n    // user -&gt; reward token -&gt; amount\n    mapping(address =&gt; mapping(address =&gt; uint256))\n        public userRewardPerTokenPaid;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    uint256 public boostedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address =&gt; Balances) public balances;\n    mapping(address =&gt; LockedBalance[]) public userLocks;\n\n    //boost\n    address public boostPayment =\n        address(0x1389388d01708118b497f59521f6943Be2541bb7);\n    uint256 public maximumBoostPayment = 0;\n    uint256 public boostRate = 10000;\n    uint256 public nextMaximumBoostPayment = 0;\n    uint256 public nextBoostRate = 10000;\n    uint256 public constant denominator = 10000;\n\n    //staking\n    uint256 public minimumStake = 10000;\n    uint256 public maximumStake = 10000;\n    address public stakingProxy;\n    address public constant cvxcrvStaking =\n        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    / ========== CONSTRUCTOR ========== /\n\n    constructor() public Ownable() {\n        _name = "Vote Locked Convex Token";\n        _symbol = "vlCVX";\n        _decimals = 18;\n\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    / ========== ADMIN CONFIGURATION ========== /\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _distributor,\n        bool _useBoost\n    ) public onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardData[_rewardsToken].useBoost = _useBoost;\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //Set the staking contract for the underlying cvx. immutable to avoid foul play\n    function setStakingContract(address _staking) external onlyOwner {\n        require(stakingProxy == address(0), "staking contract immutable");\n\n        stakingProxy = _staking;\n    }\n\n    //set staking limits. will stake the mean of the two once either ratio is crossed\n    function setStakeLimits(uint256 _minimum, uint256 _maximum)\n        external\n        onlyOwner\n    {\n        require(_minimum &lt;= denominator, "min range");\n        require(_maximum &lt;= denominator, "max range");\n        minimumStake = _minimum;\n        maximumStake = _maximum;\n        updateStakeRatio(0);\n    }\n\n    //set boost parameters\n    function setBoost(\n        uint256 _max,\n        uint256 _rate,\n        address _receivingAddress\n    ) external onlyOwner {\n        require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%\n        require(boostRate &lt; 30000, "over max rate"); //max 3x\n        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid\n        nextMaximumBoostPayment = _max;\n        nextBoostRate = _rate;\n        boostPayment = _receivingAddress;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay)\n        external\n        onlyOwner\n    {\n        require(_rate &lt;= 500, "over max rate"); //max 5% per epoch\n        require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        if (stakingProxy != address(0)) {\n            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();\n            IStakingProxy(stakingProxy).withdraw(stakeBalance);\n        }\n        isShutdown = true;\n    }\n\n    //set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));\n\n        IERC20(stakingToken).safeApprove(stakingProxy, 0);\n        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));\n    }\n\n    / ========== VIEWS ========== /\n\n    function _rewardPerToken(address _rewardsToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (boostedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(\n                    rewardData[_rewardsToken]\n                        .periodFinish\n                )\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(\n                    rewardData[_rewardsToken].useBoost\n                        ? boostedSupply\n                        : lockedSupply\n                )\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                _rewardPerToken(_rewardsToken).sub(\n                    userRewardPerTokenPaid[_user][_rewardsToken]\n                )\n            )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime)\n        internal\n        view\n        returns (uint256)\n    {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData;\n        Balances storage userBalance = balances[_account];\n        uint256 boostedBal = userBalance.boosted;\n        for (uint256 i = 0; i &lt; userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(\n                _account,\n                token,\n                rewardData[token].useBoost ? boostedBal : userBalance.locked\n            );\n        }\n        return userRewards;\n    }\n\n    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens\n    function rewardWeightOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].boosted;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        return balances[_user].locked;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n\n        //start with current boosted amount\n        amount = balances[_user].boosted;\n\n        uint256 locksLength = locks.length;\n        //remove old records only (will be better gas-wise than adding up)\n        for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {\n            if (locks[i].unlockTime &lt;= block.timestamp) {\n                amount = amount.sub(locks[i].boosted);\n            } else {\n                //stop now as no futher checks are needed\n                break;\n            }\n        }\n\n        //also remove amount in the current epoch\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength &gt; 0 &amp;&amp;\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==\n            currentEpoch\n        ) {\n            amount = amount.sub(locks[locksLength - 1].boosted);\n        }\n\n        return amount;\n    }\n\n    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //current epoch is not counted\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we\'re basing from.\n            //also not include the current epoch\n            if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {\n                if (lockEpoch &gt; cutoffEpoch) {\n                    amount = amount.add(locks[i].boosted);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //supply of all properly locked BOOSTED balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked BOOSTED balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch)\n        external\n        view\n        returns (uint256 supply)\n    {\n        uint256 epochStart =\n            uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n                rewardsDuration\n            );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n\n        //do not include current epoch\'s supply\n        if (uint256(epochs[_epoch].date) == currentEpoch) {\n            _epoch--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) &lt;= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) external view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i &lt; 128; i++) {\n            if (min &gt;= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock &lt; _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user\'s locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {\n            if (locks[i].unlockTime &gt; block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance;\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    / ========== MUTATIVE FUNCTIONS ========== /\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date &lt; currentEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate =\n                    uint256(epochs[epochs.length - 1].date).add(\n                        rewardsDuration\n                    );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n\n            //update boost parameters on a new epoch\n            if (boostRate != nextBoostRate) {\n                boostRate = nextBoostRate;\n            }\n            if (maximumBoostPayment != nextMaximumBoostPayment) {\n                maximumBoostPayment = nextMaximumBoostPayment;\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, _spendRatio);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) internal {\n        require(_amount &gt; 0, "Cannot stake 0");\n        require(_spendRatio &lt;= maximumBoostPayment, "over max spend");\n        require(!isShutdown, "shutdown");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //calc lock and boosted amount\n        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);\n        uint256 boostRatio =\n            boostRate.mul(_spendRatio).div(\n                maximumBoostPayment == 0 ? 1 : maximumBoostPayment\n            );\n        uint112 lockAmount = _amount.sub(spendAmount).to112();\n        uint112 boostedAmount =\n            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();\n\n        //add user balances\n        bal.locked = bal.locked.add(lockAmount);\n        bal.boosted = bal.boosted.add(boostedAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n        boostedSupply = boostedSupply.add(boostedAmount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch =\n            block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({\n                    amount: lockAmount,\n                    boosted: boostedAmount,\n                    unlockTime: uint32(unlockTime)\n                })\n            );\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n            userL.boosted = userL.boosted.add(boostedAmount);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(uint224(boostedAmount));\n\n        //send boost payment\n        if (spendAmount &gt; 0) {\n            stakingToken.safeTransfer(boostPayment, spendAmount);\n        }\n\n        //update staking, allow a bit of leeway for smaller deposits to reduce gas\n        updateStakeRatio(stakeOffsetOnLock);\n\n        emit Staked(_account, _amount, lockAmount, boostedAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint112 boostedAmount;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (\n            isShutdown ||\n            locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)\n        ) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n            boostedAmount = userBalance.boosted;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we\'ll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay &gt; 0) {\n                uint256 currentEpoch =\n                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                        rewardsDuration\n                    );\n                uint256 epochsover =\n                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                        rewardsDuration\n                    );\n                uint256 rRate =\n                    MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(\n                    denominator\n                );\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i &lt; length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))\n                    break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n                boostedAmount = boostedAmount.add(locks[i].boosted);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay &gt; 0) {\n                    uint256 currentEpoch =\n                        block\n                            .timestamp\n                            .sub(_checkDelay)\n                            .div(rewardsDuration)\n                            .mul(rewardsDuration);\n                    uint256 epochsover =\n                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                            rewardsDuration\n                        );\n                    uint256 rRate =\n                        MathUtil.min(\n                            kickRewardPerEpoch.mul(epochsover + 1),\n                            denominator\n                        );\n                    reward = reward.add(\n                        uint256(locks[i].amount).mul(rRate).div(denominator)\n                    );\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked &gt; 0, "no exp locks");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        userBalance.boosted = userBalance.boosted.sub(boostedAmount);\n        lockedSupply = lockedSupply.sub(locked);\n        boostedSupply = boostedSupply.sub(boostedAmount);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward &gt; 0) {\n            //if theres a reward(kicked), it will always be a withdraw only\n            //preallocate enough cvx from stake contract to pay for both reward and withdraw\n            allocateCVXForTransfer(uint256(locked));\n\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            transferCVX(_rewardAddress, reward, false);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        } else if (_spendRatio &gt; 0) {\n            //preallocate enough cvx to transfer the boost cost\n            allocateCVXForTransfer(\n                uint256(locked).mul(_spendRatio).div(denominator)\n            );\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, _spendRatio);\n        } else {\n            transferCVX(_withdrawTo, locked, true);\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(\n        bool _relock,\n        uint256 _spendRatio,\n        address _withdrawTo\n    ) external nonReentrant {\n        _processExpiredLocks(\n            msg.sender,\n            _relock,\n            _spendRatio,\n            _withdrawTo,\n            msg.sender,\n            0\n        );\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of \'kickRewardEpochDelay\'\n        _processExpiredLocks(\n            _account,\n            false,\n            0,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    //pull required amount of cvx from staking for an upcoming transfer\n    function allocateCVXForTransfer(uint256 _amount) internal {\n        uint256 balance = stakingToken.balanceOf(address(this));\n        if (_amount &gt; balance) {\n            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));\n        }\n    }\n\n    //transfer helper: pull enough from staking, transfer, updating staking ratio\n    function transferCVX(\n        address _account,\n        uint256 _amount,\n        bool _updateStake\n    ) internal {\n        //allocate enough cvx from staking for the transfer\n        allocateCVXForTransfer(_amount);\n        //transfer\n        stakingToken.safeTransfer(_account, _amount);\n\n        //update staking\n        if (_updateStake) {\n            updateStakeRatio(0);\n        }\n    }\n\n    //calculate how much cvx should be staked. update if needed\n    function updateStakeRatio(uint256 _offset) internal {\n        if (isShutdown) return;\n\n        //get balances\n        uint256 local = stakingToken.balanceOf(address(this));\n        uint256 staked = IStakingProxy(stakingProxy).getBalance();\n        uint256 total = local.add(staked);\n\n        if (total == 0) return;\n\n        //current staked ratio\n        uint256 ratio = staked.mul(denominator).div(total);\n        //mean will be where we reset to if unbalanced\n        uint256 mean = maximumStake.add(minimumStake).div(2);\n        uint256 max = maximumStake.add(_offset);\n        uint256 min = Math.min(minimumStake, minimumStake - _offset);\n        if (ratio &gt; max) {\n            //remove\n            uint256 remove = staked.sub(total.mul(mean).div(denominator));\n            IStakingProxy(stakingProxy).withdraw(remove);\n        } else if (ratio &lt; min) {\n            //add\n            uint256 increase = total.mul(mean).div(denominator).sub(staked);\n            stakingToken.safeTransfer(stakingProxy, increase);\n            IStakingProxy(stakingProxy).stake();\n        }\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake)\n        public\n        nonReentrant\n        updateReward(_account)\n    {\n        for (uint256 i; i &lt; rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward &gt; 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (_rewardsToken == cvxCrv &amp;&amp; _stake) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    / ========== RESTRICTED FUNCTIONS ========== /\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp &gt;= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining =\n                uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward\n                .add(leftover)\n                .div(rewardsDuration)\n                .to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n        require(_reward &gt; 0, "No reward");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via transferFrom to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _reward\n        );\n\n        emit RewardAdded(_rewardsToken, _reward);\n\n        if (_rewardsToken == cvxCrv) {\n            //update staking ratio if main reward\n            updateStakeRatio(0);\n        }\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            _tokenAddress != address(stakingToken),\n            "Cannot withdraw staking token"\n        );\n        require(\n            rewardData[_tokenAddress].lastUpdateTime == 0,\n            "Cannot withdraw reward token"\n        );\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    / ========== MODIFIERS ========== /\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n            uint256 boostedBal = userBalance.boosted;\n            for (uint256 i = 0; i &lt; rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)\n                    .to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token]\n                        .periodFinish\n                )\n                    .to40();\n                if (_account != address(0)) {\n                    //check if reward is boostable or not. use boosted or locked balance accordingly\n                    rewards[_account][token] = _earned(\n                        _account,\n                        token,\n                        rewardData[token].useBoost\n                            ? boostedBal\n                            : userBalance.locked\n                    );\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        ;\n    }\n\n    / ========== EVENTS ========== /\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 _paidAmount,\n        uint256 _lockedAmount,\n        uint256 _boostedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(\n        address indexed _user,\n        address indexed _kicked,\n        uint256 _reward\n    );\n    event RewardPaid(\n        address indexed _user,\n        address indexed _rewardsToken,\n        uint256 _reward\n    );\n    event Recovered(address _token, uint256 _amount);\n}\n', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-19-08 15:45:34 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "../../interfaces/cvx/MathUtil.sol"; import "../../interfaces/cvx/IStakingProxy.sol"; import "../../interfaces/cvx/IRewardStaking.sol"; import "../../interfaces/cvx/BoringMath.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol"; import "@openzeppelin/contracts/math/Math.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; // CVX Locking contract for https://www.convexfinance.com/ // CVX locked in this contract will be entitled to voting rights for the Convex Finance platform // Based on EPS Staking contract for http://ellipsis.finance/ // Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards contract CvxLocker is ReentrancyGuard, Ownable {     using BoringMath for uint256;     using BoringMath224 for uint224;     using BoringMath112 for uint112;     using BoringMath32 for uint32;     using SafeERC20 for IERC20; /* ========== STATE VARIABLES ========== */  struct Reward {     bool useBoost;     uint40 periodFinish;     uint208 rewardRate;     uint40 lastUpdateTime;     uint208 rewardPerTokenStored; } struct Balances {     uint112 locked;     uint112 boosted;     uint32 nextUnlockIndex; } struct LockedBalance {     uint112 amount;     uint112 boosted;     uint32 unlockTime; } struct EarnedData {     address token;     uint256 amount; } struct Epoch {     uint224 supply; //epoch boosted supply     uint32 date; //epoch start date }  //token constants IERC20 public constant stakingToken =     IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx address public constant cvxCrv =     address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);  //rewards address[] public rewardTokens; mapping(address =&gt; Reward) public rewardData;  // Duration that rewards are streamed over uint256 public constant rewardsDuration = 86400 * 7;  // Duration of lock/earned penalty period uint256 public constant lockDuration = rewardsDuration * 17;  // reward token -&gt; distributor -&gt; is approved to add rewards mapping(address =&gt; mapping(address =&gt; bool)) public rewardDistributors;  // user -&gt; reward token -&gt; amount mapping(address =&gt; mapping(address =&gt; uint256))     public userRewardPerTokenPaid; mapping(address =&gt; mapping(address =&gt; uint256)) public rewards;  //supplies and epochs uint256 public lockedSupply; uint256 public boostedSupply; Epoch[] public epochs;  //mappings for balance data mapping(address =&gt; Balances) public balances; mapping(address =&gt; LockedBalance[]) public userLocks;  //boost address public boostPayment =     address(0x1389388d01708118b497f59521f6943Be2541bb7); uint256 public maximumBoostPayment = 0; uint256 public boostRate = 10000; uint256 public nextMaximumBoostPayment = 0; uint256 public nextBoostRate = 10000; uint256 public constant denominator = 10000;  //staking uint256 public minimumStake = 10000; uint256 public maximumStake = 10000; address public stakingProxy; address public constant cvxcrvStaking =     address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing  //management uint256 public kickRewardPerEpoch = 100; uint256 public kickRewardEpochDelay = 4;  //shutdown bool public isShutdown = false;  //erc20-like interface string private _name; string private _symbol; uint8 private immutable _decimals;  /* ========== CONSTRUCTOR ========== */  constructor() public Ownable() {     _name = "Vote Locked Convex Token";     _symbol = "vlCVX";     _decimals = 18;      uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)})); }  function decimals() public view returns (uint8) {     return _decimals; }  function name() public view returns (string memory) {     return _name; }  function symbol() public view returns (string memory) {     return _symbol; }  /* ========== ADMIN CONFIGURATION ========== */  // Add a new reward token to be distributed to stakers function addReward(     address _rewardsToken,     address _distributor,     bool _useBoost ) public onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime == 0);     require(_rewardsToken != address(stakingToken));     rewardTokens.push(_rewardsToken);     rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);     rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);     rewardData[_rewardsToken].useBoost = _useBoost;     rewardDistributors[_rewardsToken][_distributor] = true; }  // Modify approval for an address to call notifyRewardAmount function approveRewardDistributor(     address _rewardsToken,     address _distributor,     bool _approved ) external onlyOwner {     require(rewardData[_rewardsToken].lastUpdateTime &gt; 0);     rewardDistributors[_rewardsToken][_distributor] = _approved; }  //Set the staking contract for the underlying cvx. immutable to avoid foul play function setStakingContract(address _staking) external onlyOwner {     require(stakingProxy == address(0), "staking contract immutable");      stakingProxy = _staking; }  //set staking limits. will stake the mean of the two once either ratio is crossed function setStakeLimits(uint256 _minimum, uint256 _maximum)     external     onlyOwner {     require(_minimum &lt;= denominator, "min range");     require(_maximum &lt;= denominator, "max range");     minimumStake = _minimum;     maximumStake = _maximum;     updateStakeRatio(0); }  //set boost parameters function setBoost(     uint256 _max,     uint256 _rate,     address _receivingAddress ) external onlyOwner {     require(maximumBoostPayment &lt; 1500, "over max payment"); //max 15%     require(boostRate &lt; 30000, "over max rate"); //max 3x     require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid     nextMaximumBoostPayment = _max;     nextBoostRate = _rate;     boostPayment = _receivingAddress; }  //set kick incentive function setKickIncentive(uint256 _rate, uint256 _delay)     external     onlyOwner {     require(_rate &lt;= 500, "over max rate"); //max 5% per epoch     require(_delay &gt;= 2, "min delay"); //minimum 2 epochs of grace     kickRewardPerEpoch = _rate;     kickRewardEpochDelay = _delay; }  //shutdown the contract. unstake all tokens. release all locks function shutdown() external onlyOwner {     if (stakingProxy != address(0)) {         uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();         IStakingProxy(stakingProxy).withdraw(stakeBalance);     }     isShutdown = true; }  //set approvals for staking cvx and cvxcrv function setApprovals() external {     IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);     IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));      IERC20(stakingToken).safeApprove(stakingProxy, 0);     IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1)); }  /* ========== VIEWS ========== */  function _rewardPerToken(address _rewardsToken)     internal     view     returns (uint256) {     if (boostedSupply == 0) {         return rewardData[_rewardsToken].rewardPerTokenStored;     }     return         uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(             _lastTimeRewardApplicable(                 rewardData[_rewardsToken]                     .periodFinish             )                 .sub(rewardData[_rewardsToken].lastUpdateTime)                 .mul(rewardData[_rewardsToken].rewardRate)                 .mul(1e18)                 .div(                 rewardData[_rewardsToken].useBoost                     ? boostedSupply                     : lockedSupply             )         ); }  function _earned(     address _user,     address _rewardsToken,     uint256 _balance ) internal view returns (uint256) {     return         _balance             .mul(             _rewardPerToken(_rewardsToken).sub(                 userRewardPerTokenPaid[_user][_rewardsToken]             )         )             .div(1e18)             .add(rewards[_user][_rewardsToken]); }  function _lastTimeRewardApplicable(uint256 _finishTime)     internal     view     returns (uint256) {     return Math.min(block.timestamp, _finishTime); }  function lastTimeRewardApplicable(address _rewardsToken)     public     view     returns (uint256) {     return         _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish); }  function rewardPerToken(address _rewardsToken)     external     view     returns (uint256) {     return _rewardPerToken(_rewardsToken); }  function getRewardForDuration(address _rewardsToken)     external     view     returns (uint256) {     return         uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration); }  // Address and claimable amount of all reward tokens for the given account function claimableRewards(address _account)     external     view     returns (EarnedData[] memory userRewards) {     userRewards = new EarnedData[](rewardTokens.length);     Balances storage userBalance = balances[_account];     uint256 boostedBal = userBalance.boosted;     for (uint256 i = 0; i &lt; userRewards.length; i++) {         address token = rewardTokens[i];         userRewards[i].token = token;         userRewards[i].amount = _earned(             _account,             token,             rewardData[token].useBoost ? boostedBal : userBalance.locked         );     }     return userRewards; }  // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens function rewardWeightOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].boosted; }  // total token balance of an account, including unlocked but not withdrawn tokens function lockedBalanceOf(address _user)     external     view     returns (uint256 amount) {     return balances[_user].locked; }  //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch function balanceOf(address _user) external view returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;      //start with current boosted amount     amount = balances[_user].boosted;      uint256 locksLength = locks.length;     //remove old records only (will be better gas-wise than adding up)     for (uint256 i = nextUnlockIndex; i &lt; locksLength; i++) {         if (locks[i].unlockTime &lt;= block.timestamp) {             amount = amount.sub(locks[i].boosted);         } else {             //stop now as no futher checks are needed             break;         }     }      //also remove amount in the current epoch     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     if (         locksLength &gt; 0 &amp;&amp;         uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==         currentEpoch     ) {         amount = amount.sub(locks[locksLength - 1].boosted);     }      return amount; }  //BOOSTED balance of an account which only includes properly locked tokens at the given epoch function balanceAtEpochOf(uint256 _epoch, address _user)     external     view     returns (uint256 amount) {     LockedBalance[] storage locks = userLocks[_user];      //get timestamp of given epoch index     uint256 epochTime = epochs[_epoch].date;     //get timestamp of first non-inclusive epoch     uint256 cutoffEpoch = epochTime.sub(lockDuration);      //current epoch is not counted     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //need to add up since the range could be in the middle somewhere     //traverse inversely to make more current queries more gas efficient     for (uint256 i = locks.length - 1; i + 1 != 0; i--) {         uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);         //lock epoch must be less or equal to the epoch we're basing from.         //also not include the current epoch         if (lockEpoch &lt;= epochTime &amp;&amp; lockEpoch &lt; currentEpoch) {             if (lockEpoch &gt; cutoffEpoch) {                 amount = amount.add(locks[i].boosted);             } else {                 //stop now as no futher checks matter                 break;             }         }     }      return amount; }  //supply of all properly locked BOOSTED balances at most recent eligible epoch function totalSupply() external view returns (uint256 supply) {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 cutoffEpoch = currentEpoch.sub(lockDuration);     uint256 epochindex = epochs.length;      //do not include current epoch's supply     if (uint256(epochs[epochindex - 1].date) == currentEpoch) {         epochindex--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = epochindex - 1; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(e.supply);     }      return supply; }  //supply of all properly locked BOOSTED balances at the given epoch function totalSupplyAtEpoch(uint256 _epoch)     external     view     returns (uint256 supply) {     uint256 epochStart =         uint256(epochs[_epoch].date).div(rewardsDuration).mul(             rewardsDuration         );     uint256 cutoffEpoch = epochStart.sub(lockDuration);     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);      //do not include current epoch's supply     if (uint256(epochs[_epoch].date) == currentEpoch) {         _epoch--;     }      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) &lt;= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; }  //find an epoch index based on timestamp function findEpochId(uint256 _time) external view returns (uint256 epoch) {     uint256 max = epochs.length - 1;     uint256 min = 0;      //convert to start point     _time = _time.div(rewardsDuration).mul(rewardsDuration);      for (uint256 i = 0; i &lt; 128; i++) {         if (min &gt;= max) break;          uint256 mid = (min + max + 1) / 2;         uint256 midEpochBlock = epochs[mid].date;         if (midEpochBlock == _time) {             //found             return mid;         } else if (midEpochBlock &lt; _time) {             min = mid;         } else {             max = mid - 1;         }     }     return min; }  // Information on a user's locked balances function lockedBalances(address _user)     external     view     returns (         uint256 total,         uint256 unlockable,         uint256 locked,         LockedBalance[] memory lockData     ) {     LockedBalance[] storage locks = userLocks[_user];     Balances storage userBalance = balances[_user];     uint256 nextUnlockIndex = userBalance.nextUnlockIndex;     uint256 idx;     for (uint256 i = nextUnlockIndex; i &lt; locks.length; i++) {         if (locks[i].unlockTime &gt; block.timestamp) {             if (idx == 0) {                 lockData = new LockedBalance[](locks.length - i);             }             lockData[idx] = locks[i];             idx++;             locked = locked.add(locks[i].amount);         } else {             unlockable = unlockable.add(locks[i].amount);         }     }     return (userBalance.locked, unlockable, locked, lockData); }  //number of epochs function epochCount() external view returns (uint256) {     return epochs.length; }  /* ========== MUTATIVE FUNCTIONS ========== */  function checkpointEpoch() external {     _checkpointEpoch(); }  //insert a new epoch if needed. fill in any gaps function _checkpointEpoch() internal {     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 epochindex = epochs.length;      //first epoch add in constructor, no need to check 0 length      //check to add     if (epochs[epochindex - 1].date &lt; currentEpoch) {         //fill any epoch gaps         while (epochs[epochs.length - 1].date != currentEpoch) {             uint256 nextEpochDate =                 uint256(epochs[epochs.length - 1].date).add(                     rewardsDuration                 );             epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));         }          //update boost parameters on a new epoch         if (boostRate != nextBoostRate) {             boostRate = nextBoostRate;         }         if (maximumBoostPayment != nextMaximumBoostPayment) {             maximumBoostPayment = nextMaximumBoostPayment;         }     } }  // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards function lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) external nonReentrant updateReward(_account) {     //pull tokens     stakingToken.safeTransferFrom(msg.sender, address(this), _amount);      //lock     _lock(_account, _amount, _spendRatio); }  //lock tokens function _lock(     address _account,     uint256 _amount,     uint256 _spendRatio ) internal {     require(_amount &gt; 0, "Cannot stake 0");     require(_spendRatio &lt;= maximumBoostPayment, "over max spend");     require(!isShutdown, "shutdown");      Balances storage bal = balances[_account];      //must try check pointing epoch first     _checkpointEpoch();      //calc lock and boosted amount     uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);     uint256 boostRatio =         boostRate.mul(_spendRatio).div(             maximumBoostPayment == 0 ? 1 : maximumBoostPayment         );     uint112 lockAmount = _amount.sub(spendAmount).to112();     uint112 boostedAmount =         _amount.add(_amount.mul(boostRatio).div(denominator)).to112();      //add user balances     bal.locked = bal.locked.add(lockAmount);     bal.boosted = bal.boosted.add(boostedAmount);      //add to total supplies     lockedSupply = lockedSupply.add(lockAmount);     boostedSupply = boostedSupply.add(boostedAmount);      //add user lock records or add to current     uint256 currentEpoch =         block.timestamp.div(rewardsDuration).mul(rewardsDuration);     uint256 unlockTime = currentEpoch.add(lockDuration);     uint256 idx = userLocks[_account].length;     if (idx == 0 || userLocks[_account][idx - 1].unlockTime &lt; unlockTime) {         userLocks[_account].push(             LockedBalance({                 amount: lockAmount,                 boosted: boostedAmount,                 unlockTime: uint32(unlockTime)             })         );     } else {         LockedBalance storage userL = userLocks[_account][idx - 1];         userL.amount = userL.amount.add(lockAmount);         userL.boosted = userL.boosted.add(boostedAmount);     }      //update epoch supply, epoch checkpointed above so safe to add to latest     Epoch storage e = epochs[epochs.length - 1];     e.supply = e.supply.add(uint224(boostedAmount));      //send boost payment     if (spendAmount &gt; 0) {         stakingToken.safeTransfer(boostPayment, spendAmount);     }      //update staking, allow a bit of leeway for smaller deposits to reduce gas     updateStakeRatio(stakeOffsetOnLock);      emit Staked(_account, _amount, lockAmount, boostedAmount); }  // Withdraw all currently locked tokens where the unlock time has passed function _processExpiredLocks(     address _account,     bool _relock,     uint256 _spendRatio,     address _withdrawTo,     address _rewardAddress,     uint256 _checkDelay ) internal updateReward(_account) {     LockedBalance[] storage locks = userLocks[_account];     Balances storage userBalance = balances[_account];     uint112 locked;     uint112 boostedAmount;     uint256 length = locks.length;     uint256 reward = 0;      if (         isShutdown ||         locks[length - 1].unlockTime &lt;= block.timestamp.sub(_checkDelay)     ) {         //if time is beyond last lock, can just bundle everything together         locked = userBalance.locked;         boostedAmount = userBalance.boosted;          //dont delete, just set next index         userBalance.nextUnlockIndex = length.to32();          //check for kick reward         //this wont have the exact reward rate that you would get if looped through         //but this section is supposed to be for quick and easy low gas processing of all locks         //we'll assume that if the reward was good enough someone would have processed at an earlier epoch         if (_checkDelay &gt; 0) {             uint256 currentEpoch =                 block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                     rewardsDuration                 );             uint256 epochsover =                 currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(                     rewardsDuration                 );             uint256 rRate =                 MathUtil.min(                     kickRewardPerEpoch.mul(epochsover + 1),                     denominator                 );             reward = uint256(locks[length - 1].amount).mul(rRate).div(                 denominator             );         }     } else {         //use a processed index(nextUnlockIndex) to not loop as much         //deleting does not change array length         uint32 nextUnlockIndex = userBalance.nextUnlockIndex;         for (uint256 i = nextUnlockIndex; i &lt; length; i++) {             //unlock time must be less or equal to time             if (locks[i].unlockTime &gt; block.timestamp.sub(_checkDelay))                 break;              //add to cumulative amounts             locked = locked.add(locks[i].amount);             boostedAmount = boostedAmount.add(locks[i].boosted);              //check for kick reward             //each epoch over due increases reward             if (_checkDelay &gt; 0) {                 uint256 currentEpoch =                     block                         .timestamp                         .sub(_checkDelay)                         .div(rewardsDuration)                         .mul(rewardsDuration);                 uint256 epochsover =                     currentEpoch.sub(uint256(locks[i].unlockTime)).div(                         rewardsDuration                     );                 uint256 rRate =                     MathUtil.min(                         kickRewardPerEpoch.mul(epochsover + 1),                         denominator                     );                 reward = reward.add(                     uint256(locks[i].amount).mul(rRate).div(denominator)                 );             }             //set next unlock index             nextUnlockIndex++;         }         //update next unlock index         userBalance.nextUnlockIndex = nextUnlockIndex;     }     require(locked &gt; 0, "no exp locks");      //update user balances and total supplies     userBalance.locked = userBalance.locked.sub(locked);     userBalance.boosted = userBalance.boosted.sub(boostedAmount);     lockedSupply = lockedSupply.sub(locked);     boostedSupply = boostedSupply.sub(boostedAmount);      emit Withdrawn(_account, locked, _relock);      //send process incentive     if (reward &gt; 0) {         //if theres a reward(kicked), it will always be a withdraw only         //preallocate enough cvx from stake contract to pay for both reward and withdraw         allocateCVXForTransfer(uint256(locked));          //reduce return amount by the kick reward         locked = locked.sub(reward.to112());          //transfer reward         transferCVX(_rewardAddress, reward, false);          emit KickReward(_rewardAddress, _account, reward);     } else if (_spendRatio &gt; 0) {         //preallocate enough cvx to transfer the boost cost         allocateCVXForTransfer(             uint256(locked).mul(_spendRatio).div(denominator)         );     }      //relock or return to user     if (_relock) {         _lock(_withdrawTo, locked, _spendRatio);     } else {         transferCVX(_withdrawTo, locked, true);     } }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(     bool _relock,     uint256 _spendRatio,     address _withdrawTo ) external nonReentrant {     _processExpiredLocks(         msg.sender,         _relock,         _spendRatio,         _withdrawTo,         msg.sender,         0     ); }  // Withdraw/relock all currently locked tokens where the unlock time has passed function processExpiredLocks(bool _relock) external nonReentrant {     _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0); }  function kickExpiredLocks(address _account) external nonReentrant {     //allow kick after grace period of 'kickRewardEpochDelay'     _processExpiredLocks(         _account,         false,         0,         _account,         msg.sender,         rewardsDuration.mul(kickRewardEpochDelay)     ); }  //pull required amount of cvx from staking for an upcoming transfer function allocateCVXForTransfer(uint256 _amount) internal {     uint256 balance = stakingToken.balanceOf(address(this));     if (_amount &gt; balance) {         IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));     } }  //transfer helper: pull enough from staking, transfer, updating staking ratio function transferCVX(     address _account,     uint256 _amount,     bool _updateStake ) internal {     //allocate enough cvx from staking for the transfer     allocateCVXForTransfer(_amount);     //transfer     stakingToken.safeTransfer(_account, _amount);      //update staking     if (_updateStake) {         updateStakeRatio(0);     } }  //calculate how much cvx should be staked. update if needed function updateStakeRatio(uint256 _offset) internal {     if (isShutdown) return;      //get balances     uint256 local = stakingToken.balanceOf(address(this));     uint256 staked = IStakingProxy(stakingProxy).getBalance();     uint256 total = local.add(staked);      if (total == 0) return;      //current staked ratio     uint256 ratio = staked.mul(denominator).div(total);     //mean will be where we reset to if unbalanced     uint256 mean = maximumStake.add(minimumStake).div(2);     uint256 max = maximumStake.add(_offset);     uint256 min = Math.min(minimumStake, minimumStake - _offset);     if (ratio &gt; max) {         //remove         uint256 remove = staked.sub(total.mul(mean).div(denominator));         IStakingProxy(stakingProxy).withdraw(remove);     } else if (ratio &lt; min) {         //add         uint256 increase = total.mul(mean).div(denominator).sub(staked);         stakingToken.safeTransfer(stakingProxy, increase);         IStakingProxy(stakingProxy).stake();     } }  // Claim all pending rewards function getReward(address _account, bool _stake)     public     nonReentrant     updateReward(_account) {     for (uint256 i; i &lt; rewardTokens.length; i++) {         address _rewardsToken = rewardTokens[i];         uint256 reward = rewards[_account][_rewardsToken];         if (reward &gt; 0) {             rewards[_account][_rewardsToken] = 0;             if (_rewardsToken == cvxCrv &amp;&amp; _stake) {                 IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);             } else {                 IERC20(_rewardsToken).safeTransfer(_account, reward);             }             emit RewardPaid(_account, _rewardsToken, reward);         }     } }  // claim all pending rewards function getReward(address _account) external {     getReward(_account, false); }  /* ========== RESTRICTED FUNCTIONS ========== */  function _notifyReward(address _rewardsToken, uint256 _reward) internal {     Reward storage rdata = rewardData[_rewardsToken];      if (block.timestamp &gt;= rdata.periodFinish) {         rdata.rewardRate = _reward.div(rewardsDuration).to208();     } else {         uint256 remaining =             uint256(rdata.periodFinish).sub(block.timestamp);         uint256 leftover = remaining.mul(rdata.rewardRate);         rdata.rewardRate = _reward             .add(leftover)             .div(rewardsDuration)             .to208();     }      rdata.lastUpdateTime = block.timestamp.to40();     rdata.periodFinish = block.timestamp.add(rewardsDuration).to40(); }  function notifyRewardAmount(address _rewardsToken, uint256 _reward)     external     updateReward(address(0)) {     require(rewardDistributors[_rewardsToken][msg.sender]);     require(_reward &gt; 0, "No reward");      _notifyReward(_rewardsToken, _reward);      // handle the transfer of reward tokens via `transferFrom` to reduce the number     // of transactions required and ensure correctness of the _reward amount     IERC20(_rewardsToken).safeTransferFrom(         msg.sender,         address(this),         _reward     );      emit RewardAdded(_rewardsToken, _reward);      if (_rewardsToken == cvxCrv) {         //update staking ratio if main reward         updateStakeRatio(0);     } }  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders function recoverERC20(address _tokenAddress, uint256 _tokenAmount)     external     onlyOwner {     require(         _tokenAddress != address(stakingToken),         "Cannot withdraw staking token"     );     require(         rewardData[_tokenAddress].lastUpdateTime == 0,         "Cannot withdraw reward token"     );     IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);     emit Recovered(_tokenAddress, _tokenAmount); }  /* ========== MODIFIERS ========== */  modifier updateReward(address _account) {     {         //stack too deep         Balances storage userBalance = balances[_account];         uint256 boostedBal = userBalance.boosted;         for (uint256 i = 0; i &lt; rewardTokens.length; i++) {             address token = rewardTokens[i];             rewardData[token].rewardPerTokenStored = _rewardPerToken(token)                 .to208();             rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(                 rewardData[token]                     .periodFinish             )                 .to40();             if (_account != address(0)) {                 //check if reward is boostable or not. use boosted or locked balance accordingly                 rewards[_account][token] = _earned(                     _account,                     token,                     rewardData[token].useBoost                         ? boostedBal                         : userBalance.locked                 );                 userRewardPerTokenPaid[_account][token] = rewardData[token]                     .rewardPerTokenStored;             }         }     }     _; }  /* ========== EVENTS ========== */ event RewardAdded(address indexed _token, uint256 _reward); event Staked(     address indexed _user,     uint256 _paidAmount,     uint256 _lockedAmount,     uint256 _boostedAmount ); event Withdrawn(address indexed _user, uint256 _amount, bool _relocked); event KickReward(     address indexed _user,     address indexed _kicked,     uint256 _reward ); event RewardPaid(     address indexed _user,     address indexed _rewardsToken,     uint256 _reward ); event Recovered(address _token, uint256 _amount);  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-19-08 15:45:34 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-19-08 15:45:37 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-19-08 15:45:37 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15443
completion_tokens: 1
total_tokens: 15444
cost: $0.046333


[2024-19-08 15:45:37 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../../interfaces/cvx/MathUtil.sol";
import "../../interfaces/cvx/IStakingProxy.sol";
import "../../interfaces/cvx/IRewardStaking.sol";
import "../../interfaces/cvx/BoringMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = "Vote Locked Convex Token";
        _symbol = "vlCVX";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), "staking contract immutable");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, "min range");
        require(_maximum <= denominator, "max range");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, "over max payment"); //max 15%
        require(boostRate < 30000, "over max rate"); //max 3x
        require(_receivingAddress != address(0), "invalid address"); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, "over max rate"); //max 5% per epoch
        require(_delay >= 2, "min delay"); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, "Cannot stake 0");
        require(_spendRatio <= maximumBoostPayment, "over max spend");
        require(!isShutdown, "shutdown");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, "no exp locks");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, "No reward");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            "Cannot withdraw staking token"
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            "Cannot withdraw reward token"
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}
.]

###

[2024-19-08 15:45:37 INFO] **[Seminar Conclusion]**:

 ###

[2024-19-08 15:45:37 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=123321

**num_completion_tokens**=6037

**num_total_tokens**=129358

**duration**=101.00s

ChatDev Starts (20240819154356)

ChatDev Ends (20240819154537)



