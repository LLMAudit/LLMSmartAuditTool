Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,,,,,,,,,"<INFO> Assumption of Fixed-Length Array Identified.

```
VULNERABILITY NAME: Assumption of Fixed-Length Array in getCreditLimit function
'''
DETAILED DESCRIPTION: The function getCreditLimit assumes that the length of the limits array is equal to the number of effective stakers. However, if the effectiveCount is less than the length of the limits array, this can lead to data corruption or out-of-bounds errors when accessing the limits array. The function does not properly handle cases where the effectiveCount is less than the length of the limits array, potentially leading to incorrect credit limit calculations.

RECOMMENDED MITIGATION/FIX: Ensure that the limits array is resized to match the effectiveCount before returning it. This can be done by creating a new array of size effectiveCount and copying the relevant values from the limits array into it.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in getTotalLockedStake function
'''
DETAILED DESCRIPTION: The function getTotalLockedStake assumes that the borrowerAddresses array returned from members[staker].creditLine.borrowerAddresses has a fixed length. If the length of this array changes dynamically (e.g., if borrowers are added or removed), the function may not correctly iterate through all borrower addresses, leading to incorrect calculations of total locked stakes.

RECOMMENDED MITIGATION/FIX: Use the length property of the borrowerAddresses array to ensure that the loop iterates through the actual number of addresses present in the array, preventing out-of-bounds errors.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in updateTrust function
'''
DETAILED DESCRIPTION: The function updateTrust uses the length of the borrowerAddresses and stakerAddresses arrays to check for limits on the number of borrowers and stakers. However, if these arrays are modified elsewhere in the contract, the assumptions made here could lead to logic errors or incorrect trust updates.

RECOMMENDED MITIGATION/FIX: Always check the current length of the borrowerAddresses and stakerAddresses arrays before performing operations that depend on their lengths. This ensures that the logic remains valid even if the arrays have been modified.
'''
```

[2024-05-08 22:18:05 INFO] **[Seminar Conclusion]**:

 ","<INFO> Lack of Withdrawal Function Identified.
```

[2024-05-08 22:18:10 INFO] **[Seminar Conclusion]**:

 Upon thorough examination of the provided `UserManager` contract code, I have identified the following:

1. **Lack of Withdrawal Function**: The contract does not contain any function that allows users to withdraw their deposited funds, whether in the form of Ether or tokens. 

2. **Impact on Users**: The absence of a withdrawal function means that users who have deposited funds into the contract have no means of retrieving their assets. This poses a significant risk as users may be unable to access their funds, leading to potential loss of trust and financial implications.

Given these findings, I conclude with the following statement:

```
",,"<INFO> Potential Data Inconsistency Identified.

```
POTENTIAL DATA INCONSISTENCY
'''
The contract contains several areas where data is manipulated that could lead to inconsistencies. For instance, in the `updateTrust` function, the trust amount is updated for both the staker and borrower without ensuring that the data is consistent across both mappings. If one mapping is updated and the other is not, it could lead to a situation where the trust amount for a borrower does not match the trust amount for the corresponding staker, leading to data inconsistency.

Additionally, the `cancelVouch` function modifies the `lockedAmount` mapping for both the staker and borrower, but it does not verify that the state of the mappings is consistent before making these changes. If a malicious actor were to exploit this, they could manipulate the trust amounts in a way that leads to inconsistencies.

To mitigate these vulnerabilities, it is recommended to implement checks before modifying any state variables that ensure the integrity of the data. For example, before updating trust amounts in `updateTrust`, ensure that both mappings are updated in a single transaction or use a struct to encapsulate the trust data and update it atomically. Additionally, consider using events to log changes to state variables, which can help in tracking changes and maintaining consistency.
'''
```

[2024-05-08 22:18:24 INFO] **[Seminar Conclusion]**:

 ",,,,,,"<INFO> Precision Loss Identified.

**Precision Loss in Arithmetic Operations**
'''
The contract performs several arithmetic operations that could lead to precision loss, particularly in functions that involve calculating credit limits, vouching amounts, and locked stakes. For instance, in the `getCreditLimit` function, the calculation of available staking amounts and credit limits involves integer division, which can truncate decimal values and lead to significant errors in the final credit limit calculations. This is especially critical when dealing with small or unevenly distributed values, as it can result in unfair distributions of credit lines.

To mitigate this issue, it is recommended to use a fixed-point arithmetic library or scale values appropriately before performing division. For example, multiplying values by a constant factor before division can help maintain precision. Additionally, careful consideration should be given to the order of operations to minimize the risk of truncation.
'''

[2024-05-08 22:18:50 INFO] **[Seminar Conclusion]**:

 ","<INFO> Redundant Conditional Check Identified.

**Redundant Conditional Check in `updateTrust` Function**
'''
In the `updateTrust` function, there are checks to ensure that the `trustInfo.staker` is not the same as the `borrower`. This check is performed after verifying that the `borrower_` is not the zero address. However, the check for `trustInfo.staker != borrower` is redundant because the function is already called with `onlyMember(msg.sender)`, which implies that the caller is a member and thus cannot be the borrower in this context. This adds unnecessary complexity and gas costs to the function.

To mitigate this issue, the check for `trustInfo.staker != borrower` can be removed as it is unnecessary.
'''

**Redundant Conditional Check in `cancelVouch` Function**
'''
In the `cancelVouch` function, there is a check to ensure that the `LockedStake` is zero before allowing the cancellation of the vouch. However, this check is redundant because the function is called only by the member who is either the `staker` or the `borrower`. If the `LockedStake` is not zero, it would be more efficient to revert the transaction directly without performing this check, as it adds unnecessary complexity and gas costs.

To mitigate this issue, the check for `getLockedStake(staker, borrower) == 0` can be removed as it is unnecessary.
'''

[2024-05-08 22:18:59 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Centralization Risk Identified.

**Centralized Control via Admin Functions**
'''
The contract has multiple functions that can only be executed by the admin (e.g., `setUToken`, `setNewMemberFee`, `setCreditLimitModel`, `addMember`). This centralization of control means that if the admin's address is compromised, an attacker could potentially manipulate critical parameters of the contract, such as changing the token address, modifying fees, or adding malicious members. 

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for admin functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive operations, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for critical changes, allowing the community to react before changes are finalized.
'''

**Single Point of Failure in Member Management**
'''
The `addMember` function allows the admin to add new members directly. If the admin account is compromised, an attacker could add malicious accounts as members, which could lead to further exploitation of the contract.

**Recommended Mitigation/Fix:**
Introduce a decentralized governance mechanism where members can vote on new member applications or changes to membership status. This could be implemented through a proposal and voting system where a majority of existing members must approve new members.
'''

**Lack of Decentralized Control for Credit Limit Model**
'''
The function `_setCreditLimitModel` can only be called by the admin. If the admin's address is compromised, the attacker could set a malicious credit limit model, which could lead to financial exploitation of the contract.

**Recommended Mitigation/Fix:**
Similar to the previous points, consider implementing a governance model where changes to the credit limit model require approval from a majority of members or a designated governance contract. This would help ensure that no single entity can unilaterally change critical parameters.
'''

[2024-05-08 22:19:15 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,"<INFO> Lack of Input Validation Identified.

```
LACK OF INPUT VALIDATION IN `updateTrust` FUNCTION
'''
The `updateTrust` function does not validate the `trustAmount` input to ensure it is greater than zero. This could allow a staker to set a trust amount of zero, which may lead to unintended consequences, such as effectively removing trust without proper checks. Additionally, the function does not validate that the `borrower_` address is not a zero address before proceeding with the trust update.

Recommended Mitigation:
1. Add a check to ensure `trustAmount` is greater than zero.
2. Add a check to ensure `borrower_` is not a zero address before proceeding with the trust update.
'''

LACK OF INPUT VALIDATION IN `debtWriteOff` FUNCTION
'''
The `debtWriteOff` function does not validate that the `amount` parameter is greater than zero before proceeding with the debt write-off process. This could allow a user to attempt to write off a debt of zero, which may not be the intended behavior.

Recommended Mitigation:
1. Ensure that `amount` is greater than zero before proceeding with the debt write-off logic.
'''

LACK OF INPUT VALIDATION IN `registerMember` FUNCTION
'''
The `registerMember` function does not validate that the `newMember` address is not a zero address before proceeding with the registration process. This could lead to unintended behavior if a zero address is passed as a new member.

Recommended Mitigation:
1. Add a check to ensure `newMember` is not a zero address before proceeding with the registration.
'''

LACK OF INPUT VALIDATION IN `cancelVouch` FUNCTION
'''
The `cancelVouch` function does not validate that the `staker` and `borrower` addresses are not zero addresses before proceeding with the cancellation of the vouch. This could lead to unintended behavior if zero addresses are passed.

Recommended Mitigation:
1. Add checks to ensure both `staker` and `borrower` are not zero addresses before proceeding with the cancellation logic.
'''
```

[2024-05-08 22:21:09 INFO] **[Seminar Conclusion]**:

 ",
,,,,,,,,,,,"<INFO> Assumption of Fixed-Length Array Identified.

```
VULNERABILITY NAME: Assumption of Fixed-Length Array in getCreditLimit function
'''
DETAILED DESCRIPTION: The function getCreditLimit assumes that the length of the limits array is equal to the number of effective stakers. However, if the effectiveCount is less than the length of the limits array, this can lead to data corruption or out-of-bounds errors when accessing the limits array. The function does not properly handle cases where the effectiveCount is less than the length of the limits array, potentially leading to incorrect credit limit calculations.

RECOMMENDED MITIGATION/FIX: Ensure that the limits array is resized to match the effectiveCount before returning it. This can be done by creating a new array of size effectiveCount and copying the relevant values from the limits array into it.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in getTotalLockedStake function
'''
DETAILED DESCRIPTION: The function getTotalLockedStake assumes that the borrowerAddresses array returned from members[staker].creditLine.borrowerAddresses has a fixed length. If the length of this array changes dynamically (e.g., if borrowers are added or removed), the function may not correctly iterate through all borrower addresses, leading to incorrect calculations of total locked stakes.

RECOMMENDED MITIGATION/FIX: Use the length property of the borrowerAddresses array to ensure that the loop iterates through the actual number of addresses present in the array, preventing out-of-bounds errors.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in updateTrust function
'''
DETAILED DESCRIPTION: The function updateTrust uses the length of the borrowerAddresses and stakerAddresses arrays to check for limits on the number of borrowers and stakers. However, if these arrays are modified elsewhere in the contract, the assumptions made here could lead to logic errors or incorrect trust updates.

RECOMMENDED MITIGATION/FIX: Always check the current length of the borrowerAddresses and stakerAddresses arrays before performing operations that depend on their lengths. This ensures that the logic remains valid even if the arrays have been modified.
'''
```

[2024-05-08 22:18:05 INFO] **[Execute Detail]**

execute SimplePhase:[WithdrawalFunctionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:18:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the Lack of Withdrawal Function. Your analysis should determine if the contract provides a secure method for users to withdraw their funds. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to determine if there is a function that allows users to withdraw their deposited funds. 2. Scan the contract for any functions related to withdrawing Ether or other assets. Document each instance and investigate the logic to ensure it is implemented securely. 3. Evaluate whether the withdrawal function, if present, follows best practices to prevent common vulnerabilities such as reentrancy attacks. Ensure it uses the Checks-Effects-Interactions pattern. 4. If no withdrawal function is found, assess the impact on users who have deposited funds into the contract. Highlight the importance of having a secure withdrawal mechanism. If you discover a lack of a withdrawal function, respond with: "" Lack of Withdrawal Function Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If a secure withdrawal function is found and no issues are identified, respond only with: "" Withdrawal Function Present and Secure."" |
| **phase_name** | WithdrawalFunctionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /*\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     /\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': "" Assumption of Fixed-Length Array Identified.\n\n\nVULNERABILITY NAME: Assumption of Fixed-Length Array in getCreditLimit function\n'''\nDETAILED DESCRIPTION: The function getCreditLimit assumes that the length of the limits array is equal to the number of effective stakers. However, if the effectiveCount is less than the length of the limits array, this can lead to data corruption or out-of-bounds errors when accessing the limits array. The function does not properly handle cases where the effectiveCount is less than the length of the limits array, potentially leading to incorrect credit limit calculations.\n\nRECOMMENDED MITIGATION/FIX: Ensure that the limits array is resized to match the effectiveCount before returning it. This can be done by creating a new array of size effectiveCount and copying the relevant values from the limits array into it.\n'''\n\nVULNERABILITY NAME: Assumption of Fixed-Length Array in getTotalLockedStake function\n'''\nDETAILED DESCRIPTION: The function getTotalLockedStake assumes that the borrowerAddresses array returned from members[staker].creditLine.borrowerAddresses has a fixed length. If the length of this array changes dynamically (e.g., if borrowers are added or removed), the function may not correctly iterate through all borrower addresses, leading to incorrect calculations of total locked stakes.\n\nRECOMMENDED MITIGATION/FIX: Use the length property of the borrowerAddresses array to ensure that the loop iterates through the actual number of addresses present in the array, preventing out-of-bounds errors.\n'''\n\nVULNERABILITY NAME: Assumption of Fixed-Length Array in updateTrust function\n'''\nDETAILED DESCRIPTION: The function updateTrust uses the length of the borrowerAddresses and stakerAddresses arrays to check for limits on the number of borrowers and stakers. However, if these arrays are modified elsewhere in the contract, the assumptions made here could lead to logic errors or incorrect trust updates.\n\nRECOMMENDED MITIGATION/FIX: Always check the current length of the borrowerAddresses and stakerAddresses arrays before performing operations that depend on their lengths. This ensures that the logic remains valid even if the arrays have been modified.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:18:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:18:05 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
"".
Ideas: "" Assumption of Fixed-Length Array Identified.

```
VULNERABILITY NAME: Assumption of Fixed-Length Array in getCreditLimit function
'''
DETAILED DESCRIPTION: The function getCreditLimit assumes that the length of the limits array is equal to the number of effective stakers. However, if the effectiveCount is less than the length of the limits array, this can lead to data corruption or out-of-bounds errors when accessing the limits array. The function does not properly handle cases where the effectiveCount is less than the length of the limits array, potentially leading to incorrect credit limit calculations.

RECOMMENDED MITIGATION/FIX: Ensure that the limits array is resized to match the effectiveCount before returning it. This can be done by creating a new array of size effectiveCount and copying the relevant values from the limits array into it.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in getTotalLockedStake function
'''
DETAILED DESCRIPTION: The function getTotalLockedStake assumes that the borrowerAddresses array returned from members[staker].creditLine.borrowerAddresses has a fixed length. If the length of this array changes dynamically (e.g., if borrowers are added or removed), the function may not correctly iterate through all borrower addresses, leading to incorrect calculations of total locked stakes.

RECOMMENDED MITIGATION/FIX: Use the length property of the borrowerAddresses array to ensure that the loop iterates through the actual number of addresses present in the array, preventing out-of-bounds errors.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in updateTrust function
'''
DETAILED DESCRIPTION: The function updateTrust uses the length of the borrowerAddresses and stakerAddresses arrays to check for limits on the number of borrowers and stakers. However, if these arrays are modified elsewhere in the contract, the assumptions made here could lead to logic errors or incorrect trust updates.

RECOMMENDED MITIGATION/FIX: Always check the current length of the borrowerAddresses and stakerAddresses arrays before performing operations that depend on their lengths. This ensures that the logic remains valid even if the arrays have been modified.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the Lack of Withdrawal Function. Your analysis should determine if the contract provides a secure method for users to withdraw their funds.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to determine if there is a function that allows users to withdraw their deposited funds.
2. Scan the contract for any functions related to withdrawing Ether or other assets. Document each instance and investigate the logic to ensure it is implemented securely.
3. Evaluate whether the withdrawal function, if present, follows best practices to prevent common vulnerabilities such as reentrancy attacks. Ensure it uses the Checks-Effects-Interactions pattern.
4. If no withdrawal function is found, assess the impact on users who have deposited funds into the contract. Highlight the importance of having a secure withdrawal mechanism.
If you discover a lack of a withdrawal function, respond with: ""","<INFO> Lack of Withdrawal Function Identified.
```

[2024-05-08 22:18:10 INFO] **[Execute Detail]**

execute SimplePhase:[LackAuthorizationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:18:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Lack of Authorization. This type of vulnerability occurs when functions are accessible to unauthorized users, leading to potential misuse and exploitation of contract functionalities. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify all functions that modify the state of the contract or perform sensitive operations. 2. Determine if each identified function has appropriate access control mechanisms, such as onlyOwner, onlyAdmin, or other custom modifiers that restrict access to authorized users only. 3. Look for any functions that do not have explicit access control modifiers and assess whether their unrestricted access could lead to unauthorized actions. 4. Evaluate the current access control setup for potential bypasses or weaknesses that could allow unauthorized users to call restricted functions. If you discover any Lack of Authorization vulnerabilities, respond with: "" Lack of Authorization Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Lack of Authorization vulnerabilities are found, respond only with: "" NO Lack of Authorization."" |
| **phase_name** | LackAuthorizationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /*\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     /\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': ' Lack of Withdrawal Function Identified.\n```'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:18:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:18:10 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
"".
Ideas: "" Lack of Withdrawal Function Identified.
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Lack of Authorization. This type of vulnerability occurs when functions are accessible to unauthorized users, leading to potential misuse and exploitation of contract functionalities.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify all functions that modify the state of the contract or perform sensitive operations.
2. Determine if each identified function has appropriate access control mechanisms, such as `onlyOwner`, `onlyAdmin`, or other custom modifiers that restrict access to authorized users only.
3. Look for any functions that do not have explicit access control modifiers and assess whether their unrestricted access could lead to unauthorized actions.
4. Evaluate the current access control setup for potential bypasses or weaknesses that could allow unauthorized users to call restricted functions.
If you discover any Lack of Authorization vulnerabilities, respond with: """,,"<INFO> Potential Data Inconsistency Identified.

```
POTENTIAL DATA INCONSISTENCY
'''
The contract contains several areas where data is manipulated that could lead to inconsistencies. For instance, in the `updateTrust` function, the trust amount is updated for both the staker and borrower without ensuring that the data is consistent across both mappings. If one mapping is updated and the other is not, it could lead to a situation where the trust amount for a borrower does not match the trust amount for the corresponding staker, leading to data inconsistency.

Additionally, the `cancelVouch` function modifies the `lockedAmount` mapping for both the staker and borrower, but it does not verify that the state of the mappings is consistent before making these changes. If a malicious actor were to exploit this, they could manipulate the trust amounts in a way that leads to inconsistencies.

To mitigate these vulnerabilities, it is recommended to implement checks before modifying any state variables that ensure the integrity of the data. For example, before updating trust amounts in `updateTrust`, ensure that both mappings are updated in a single transaction or use a struct to encapsulate the trust data and update it atomically. Additionally, consider using events to log changes to state variables, which can help in tracking changes and maintaining consistency.
'''
```

[2024-05-08 22:18:24 INFO] **[Execute Detail]**

execute SimplePhase:[HashCollisionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:18:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any functions that generate hashes from input values. 2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of abi.encodePacked for concatenation. 3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions. 4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized. If you discover any Hash Collision vulnerabilities, respond with: "" Hash Collision Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Hash Collision vulnerabilities are found, respond only with: "" NO Hash Collision."" |
| **phase_name** | HashCollisionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /*\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     /\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': "" Potential Data Inconsistency Identified.\n\n\nPOTENTIAL DATA INCONSISTENCY\n'''\nThe contract contains several areas where data is manipulated that could lead to inconsistencies. For instance, in the `updateTrust` function, the trust amount is updated for both the staker and borrower without ensuring that the data is consistent across both mappings. If one mapping is updated and the other is not, it could lead to a situation where the trust amount for a borrower does not match the trust amount for the corresponding staker, leading to data inconsistency.\n\nAdditionally, the `cancelVouch` function modifies the `lockedAmount` mapping for both the staker and borrower, but it does not verify that the state of the mappings is consistent before making these changes. If a malicious actor were to exploit this, they could manipulate the trust amounts in a way that leads to inconsistencies.\n\nTo mitigate these vulnerabilities, it is recommended to implement checks before modifying any state variables that ensure the integrity of the data. For example, before updating trust amounts in `updateTrust`, ensure that both mappings are updated in a single transaction or use a struct to encapsulate the trust data and update it atomically. Additionally, consider using events to log changes to state variables, which can help in tracking changes and maintaining consistency.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:18:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:18:24 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
"".
Ideas: "" Potential Data Inconsistency Identified.

```
POTENTIAL DATA INCONSISTENCY
'''
The contract contains several areas where data is manipulated that could lead to inconsistencies. For instance, in the `updateTrust` function, the trust amount is updated for both the staker and borrower without ensuring that the data is consistent across both mappings. If one mapping is updated and the other is not, it could lead to a situation where the trust amount for a borrower does not match the trust amount for the corresponding staker, leading to data inconsistency.

Additionally, the `cancelVouch` function modifies the `lockedAmount` mapping for both the staker and borrower, but it does not verify that the state of the mappings is consistent before making these changes. If a malicious actor were to exploit this, they could manipulate the trust amounts in a way that leads to inconsistencies.

To mitigate these vulnerabilities, it is recommended to implement checks before modifying any state variables that ensure the integrity of the data. For example, before updating trust amounts in `updateTrust`, ensure that both mappings are updated in a single transaction or use a struct to encapsulate the trust data and update it atomically. Additionally, consider using events to log changes to state variables, which can help in tracking changes and maintaining consistency.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any functions that generate hashes from input values.
2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of `abi.encodePacked` for concatenation.
3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions.
4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized.
If you discover any Hash Collision vulnerabilities, respond with: """,,,,,,"<INFO> Precision Loss Identified.

**Precision Loss in Arithmetic Operations**
'''
The contract performs several arithmetic operations that could lead to precision loss, particularly in functions that involve calculating credit limits, vouching amounts, and locked stakes. For instance, in the `getCreditLimit` function, the calculation of available staking amounts and credit limits involves integer division, which can truncate decimal values and lead to significant errors in the final credit limit calculations. This is especially critical when dealing with small or unevenly distributed values, as it can result in unfair distributions of credit lines.

To mitigate this issue, it is recommended to use a fixed-point arithmetic library or scale values appropriately before performing division. For example, multiplying values by a constant factor before division can help maintain precision. Additionally, careful consideration should be given to the order of operations to minimize the risk of truncation.
'''

[2024-05-08 22:18:50 INFO] **[Execute Detail]**

execute SimplePhase:[RedundantConditionalDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:18:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities: 1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code. 2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution. If you identify any redundant conditional checks, respond with: "" Redundant Conditional Check Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Redundant Conditional Checks."" |
| **phase_name** | RedundantConditionalDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     */\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': "" Precision Loss Identified.\n\nPrecision Loss in Arithmetic Operations**\n'''\nThe contract performs several arithmetic operations that could lead to precision loss, particularly in functions that involve calculating credit limits, vouching amounts, and locked stakes. For instance, in the getCreditLimit function, the calculation of available staking amounts and credit limits involves integer division, which can truncate decimal values and lead to significant errors in the final credit limit calculations. This is especially critical when dealing with small or unevenly distributed values, as it can result in unfair distributions of credit lines.\n\nTo mitigate this issue, it is recommended to use a fixed-point arithmetic library or scale values appropriately before performing division. For example, multiplying values by a constant factor before division can help maintain precision. Additionally, careful consideration should be given to the order of operations to minimize the risk of truncation.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:18:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:18:50 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
"".
Ideas: "" Precision Loss Identified.

**Precision Loss in Arithmetic Operations**
'''
The contract performs several arithmetic operations that could lead to precision loss, particularly in functions that involve calculating credit limits, vouching amounts, and locked stakes. For instance, in the `getCreditLimit` function, the calculation of available staking amounts and credit limits involves integer division, which can truncate decimal values and lead to significant errors in the final credit limit calculations. This is especially critical when dealing with small or unevenly distributed values, as it can result in unfair distributions of credit lines.

To mitigate this issue, it is recommended to use a fixed-point arithmetic library or scale values appropriately before performing division. For example, multiplying values by a constant factor before division can help maintain precision. Additionally, careful consideration should be given to the order of operations to minimize the risk of truncation.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities:
1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code.
2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution.
If you identify any redundant conditional checks, respond with: ""","<INFO> Redundant Conditional Check Identified.

**Redundant Conditional Check in `updateTrust` Function**
'''
In the `updateTrust` function, there are checks to ensure that the `trustInfo.staker` is not the same as the `borrower`. This check is performed after verifying that the `borrower_` is not the zero address. However, the check for `trustInfo.staker != borrower` is redundant because the function is already called with `onlyMember(msg.sender)`, which implies that the caller is a member and thus cannot be the borrower in this context. This adds unnecessary complexity and gas costs to the function.

To mitigate this issue, the check for `trustInfo.staker != borrower` can be removed as it is unnecessary.
'''

**Redundant Conditional Check in `cancelVouch` Function**
'''
In the `cancelVouch` function, there is a check to ensure that the `LockedStake` is zero before allowing the cancellation of the vouch. However, this check is redundant because the function is called only by the member who is either the `staker` or the `borrower`. If the `LockedStake` is not zero, it would be more efficient to revert the transaction directly without performing this check, as it adds unnecessary complexity and gas costs.

To mitigate this issue, the check for `getLockedStake(staker, borrower) == 0` can be removed as it is unnecessary.
'''

[2024-05-08 22:18:59 INFO] **[Execute Detail]**

execute SimplePhase:[OracleDependencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:18:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities: 1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected. 2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations. If you identify reliance on a single external oracle for critical data, respond with: "" External Oracle Dependency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO External Oracle Dependency."" |
| **phase_name** | OracleDependencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     */\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': "" Redundant Conditional Check Identified.\n\nRedundant Conditional Check in updateTrust Function\n'''\nIn the updateTrust function, there are checks to ensure that the trustInfo.staker is not the same as the borrower. This check is performed after verifying that the borrower_ is not the zero address. However, the check for trustInfo.staker != borrower is redundant because the function is already called with onlyMember(msg.sender), which implies that the caller is a member and thus cannot be the borrower in this context. This adds unnecessary complexity and gas costs to the function.\n\nTo mitigate this issue, the check for trustInfo.staker != borrower can be removed as it is unnecessary.\n'''\n\nRedundant Conditional Check in cancelVouch Function**\n'''\nIn the cancelVouch function, there is a check to ensure that the LockedStake is zero before allowing the cancellation of the vouch. However, this check is redundant because the function is called only by the member who is either the staker or the borrower. If the LockedStake is not zero, it would be more efficient to revert the transaction directly without performing this check, as it adds unnecessary complexity and gas costs.\n\nTo mitigate this issue, the check for getLockedStake(staker, borrower) == 0 can be removed as it is unnecessary.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:18:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:18:59 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
"".
Ideas: "" Redundant Conditional Check Identified.

**Redundant Conditional Check in `updateTrust` Function**
'''
In the `updateTrust` function, there are checks to ensure that the `trustInfo.staker` is not the same as the `borrower`. This check is performed after verifying that the `borrower_` is not the zero address. However, the check for `trustInfo.staker != borrower` is redundant because the function is already called with `onlyMember(msg.sender)`, which implies that the caller is a member and thus cannot be the borrower in this context. This adds unnecessary complexity and gas costs to the function.

To mitigate this issue, the check for `trustInfo.staker != borrower` can be removed as it is unnecessary.
'''

**Redundant Conditional Check in `cancelVouch` Function**
'''
In the `cancelVouch` function, there is a check to ensure that the `LockedStake` is zero before allowing the cancellation of the vouch. However, this check is redundant because the function is called only by the member who is either the `staker` or the `borrower`. If the `LockedStake` is not zero, it would be more efficient to revert the transaction directly without performing this check, as it adds unnecessary complexity and gas costs.

To mitigate this issue, the check for `getLockedStake(staker, borrower) == 0` can be removed as it is unnecessary.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities:
1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected.
2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations.
If you identify reliance on a single external oracle for critical data, respond with: """,,,"<INFO> Centralization Risk Identified.

**Centralized Control via Admin Functions**
'''
The contract has multiple functions that can only be executed by the admin (e.g., `setUToken`, `setNewMemberFee`, `setCreditLimitModel`, `addMember`). This centralization of control means that if the admin's address is compromised, an attacker could potentially manipulate critical parameters of the contract, such as changing the token address, modifying fees, or adding malicious members. 

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for admin functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive operations, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for critical changes, allowing the community to react before changes are finalized.
'''

**Single Point of Failure in Member Management**
'''
The `addMember` function allows the admin to add new members directly. If the admin account is compromised, an attacker could add malicious accounts as members, which could lead to further exploitation of the contract.

**Recommended Mitigation/Fix:**
Introduce a decentralized governance mechanism where members can vote on new member applications or changes to membership status. This could be implemented through a proposal and voting system where a majority of existing members must approve new members.
'''

**Lack of Decentralized Control for Credit Limit Model**
'''
The function `_setCreditLimitModel` can only be called by the admin. If the admin's address is compromised, the attacker could set a malicious credit limit model, which could lead to financial exploitation of the contract.

**Recommended Mitigation/Fix:**
Similar to the previous points, consider implementing a governance model where changes to the credit limit model require approval from a majority of members or a designated governance contract. This would help ensure that no single entity can unilaterally change critical parameters.
'''

[2024-05-08 22:19:15 INFO] **[Execute Detail]**

execute SimplePhase:[FundingCalculationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:19:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities: 1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation. 2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation. If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: "" Incorrect Funding Rate Calculation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Funding Rate Calculation."" |
| **phase_name** | FundingCalculationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     */\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': "" Centralization Risk Identified.\n\nCentralized Control via Admin Functions\n'''\nThe contract has multiple functions that can only be executed by the admin (e.g., setUToken, setNewMemberFee, setCreditLimitModel, addMember). This centralization of control means that if the admin's address is compromised, an attacker could potentially manipulate critical parameters of the contract, such as changing the token address, modifying fees, or adding malicious members. \n\nRecommended Mitigation/Fix:\nImplement a multi-signature wallet for admin functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive operations, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for critical changes, allowing the community to react before changes are finalized.\n'''\n\nSingle Point of Failure in Member Management\n'''\nThe addMember function allows the admin to add new members directly. If the admin account is compromised, an attacker could add malicious accounts as members, which could lead to further exploitation of the contract.\n\nRecommended Mitigation/Fix:\nIntroduce a decentralized governance mechanism where members can vote on new member applications or changes to membership status. This could be implemented through a proposal and voting system where a majority of existing members must approve new members.\n'''\n\nLack of Decentralized Control for Credit Limit Model\n'''\nThe function _setCreditLimitModel can only be called by the admin. If the admin's address is compromised, the attacker could set a malicious credit limit model, which could lead to financial exploitation of the contract.\n\nRecommended Mitigation/Fix:**\nSimilar to the previous points, consider implementing a governance model where changes to the credit limit model require approval from a majority of members or a designated governance contract. This would help ensure that no single entity can unilaterally change critical parameters.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:19:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:19:15 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
"".
Ideas: "" Centralization Risk Identified.

**Centralized Control via Admin Functions**
'''
The contract has multiple functions that can only be executed by the admin (e.g., `setUToken`, `setNewMemberFee`, `setCreditLimitModel`, `addMember`). This centralization of control means that if the admin's address is compromised, an attacker could potentially manipulate critical parameters of the contract, such as changing the token address, modifying fees, or adding malicious members. 

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for admin functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive operations, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for critical changes, allowing the community to react before changes are finalized.
'''

**Single Point of Failure in Member Management**
'''
The `addMember` function allows the admin to add new members directly. If the admin account is compromised, an attacker could add malicious accounts as members, which could lead to further exploitation of the contract.

**Recommended Mitigation/Fix:**
Introduce a decentralized governance mechanism where members can vote on new member applications or changes to membership status. This could be implemented through a proposal and voting system where a majority of existing members must approve new members.
'''

**Lack of Decentralized Control for Credit Limit Model**
'''
The function `_setCreditLimitModel` can only be called by the admin. If the admin's address is compromised, the attacker could set a malicious credit limit model, which could lead to financial exploitation of the contract.

**Recommended Mitigation/Fix:**
Similar to the previous points, consider implementing a governance model where changes to the credit limit model require approval from a majority of members or a designated governance contract. This would help ensure that no single entity can unilaterally change critical parameters.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities:
1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation.
2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation.
If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: """,,,,,,,,,,,,,,,"<INFO> Lack of Input Validation Identified.

```
LACK OF INPUT VALIDATION IN `updateTrust` FUNCTION
'''
The `updateTrust` function does not validate the `trustAmount` input to ensure it is greater than zero. This could allow a staker to set a trust amount of zero, which may lead to unintended consequences, such as effectively removing trust without proper checks. Additionally, the function does not validate that the `borrower_` address is not a zero address before proceeding with the trust update.

Recommended Mitigation:
1. Add a check to ensure `trustAmount` is greater than zero.
2. Add a check to ensure `borrower_` is not a zero address before proceeding with the trust update.
'''

LACK OF INPUT VALIDATION IN `debtWriteOff` FUNCTION
'''
The `debtWriteOff` function does not validate that the `amount` parameter is greater than zero before proceeding with the debt write-off process. This could allow a user to attempt to write off a debt of zero, which may not be the intended behavior.

Recommended Mitigation:
1. Ensure that `amount` is greater than zero before proceeding with the debt write-off logic.
'''

LACK OF INPUT VALIDATION IN `registerMember` FUNCTION
'''
The `registerMember` function does not validate that the `newMember` address is not a zero address before proceeding with the registration process. This could lead to unintended behavior if a zero address is passed as a new member.

Recommended Mitigation:
1. Add a check to ensure `newMember` is not a zero address before proceeding with the registration.
'''

LACK OF INPUT VALIDATION IN `cancelVouch` FUNCTION
'''
The `cancelVouch` function does not validate that the `staker` and `borrower` addresses are not zero addresses before proceeding with the cancellation of the vouch. This could lead to unintended behavior if zero addresses are passed.

Recommended Mitigation:
1. Add checks to ensure both `staker` and `borrower` are not zero addresses before proceeding with the cancellation logic.
'''
```

[2024-05-08 22:21:09 INFO] **[Execute Detail]**

execute SimplePhase:[DoSDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-05-08 22:21:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."". Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases: 1. When loops have an unbounded iteration count, leading to potential gas exhaustion. 2. When the contract makes external calls that can fail or consume excessive gas. 3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures. 4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion. 2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures. 3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS. 4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics. If you identify any DoS vulnerabilities, respond with: "" DoS Vulnerability Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades. ''' If you don't find any vulnerabilities, respond only with: "" No DoS Vulnerabilities."" |
| **phase_name** | DoSDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";\nimport ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";\n\nimport ""../Controller.sol"";\nimport ""../interfaces/IAssetManager.sol"";\nimport ""../interfaces/ICreditLimitModel.sol"";\nimport ""../interfaces/IUserManager.sol"";\nimport ""../interfaces/IComptroller.sol"";\nimport ""../interfaces/IUnionToken.sol"";\nimport ""../interfaces/IDai.sol"";\nimport ""../interfaces/IUToken.sol"";\n\n/\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address =&gt; uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address =&gt; uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address =&gt; uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address =&gt; Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address =&gt; uint256) public stakers; //1 user address 2 amount\n    mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");\n        ;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            ""UserManager: caller does not the market or admin""\n        );\n        ;\n    }\n\n    /\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /\n     *  @dev Add new member event\n     *  @param member New member address\n     /\n    event LogAddMember(address member);\n\n    /\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /\n     *  @dev New member application event\n     *  @param account New member\'s voucher address\n     *  @param borrower New member address\n     /\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Cancel vouching for other member event\n     *  @param account New member\'s voucher address\n     *  @param borrower The address gets vouched for\n     /\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /\n     *  @dev Stake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /\n     *  @dev Unstake event\n     *  @param account The staker\'s address\n     *  @param amount The amount of tokens to unstake\n     /\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /\n     *  @dev DebtWriteOff event\n     *  @param staker The staker\'s address\n     *  @param borrower The borrower\'s address\n     *  @param amount The amount of write off\n     /\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        setCreditLimitModel(creditLimitModel);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1018; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     /\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            ""MemberMnager: new model is not a creditLimitModel""\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     /\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     /\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     /\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     /\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /\n     *  @dev Get the user\'s locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     /\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount &gt;= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get staker\'s defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /\n     *  @dev Get the member\'s available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     /\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount &gt; 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount &lt;= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,\n                    ""UserManager: vouchingAmount or lockedStake data error""\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256;\n        for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     /\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount &gt; totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /\n     *  @dev Get the user\'s deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     /\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), ""UserManager: address is already member"");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     /\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), ""borrower cannot be zero"");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, ""UserManager: Can\'t vouch for self"");\n        require(\n            members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;\n                members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,\n            ""UserManager: trust reach limit""\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount &gt;= trustInfo.lockedStake,\n            ""UserManager: trust amount cannot be less than the locked amount ""\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            ""UserManager: Accept claims only from the staker or borrower""\n        );\n\n        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i &lt; stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i &lt; borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     /\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), ""UserManager: address is already member"");\n        require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),\n            ""UserManager: not enough effective stakers""\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo;\n\n        for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /\n     *  @dev Stake\n     *  @param amount Amount\n     /\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) &gt;= amount,\n            ""UserManager: not enough allowance to stake""\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /\n     *  @dev Unstake\n     *  @param amount Amount\n     /\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,\n            ""UserManager: unstake balance is insufficient""\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            ""UserManager: withdraw failed""\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards &gt; 0, ""UserManager: not enough rewards"");\n    }\n\n    /\n     *  @dev Repay user\'s loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     /\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount &gt; 0, ""UserManager: amount can not be zero"");\n        require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");\n        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] &gt;= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /*\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     /\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, ""UserManager: params length error"");\n        require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i &lt; accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen &gt; memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks &gt;= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\n', 'ideas': "" Lack of Input Validation Identified.\n\n\nLACK OF INPUT VALIDATION IN `updateTrust` FUNCTION\n'''\nThe `updateTrust` function does not validate the `trustAmount` input to ensure it is greater than zero. This could allow a staker to set a trust amount of zero, which may lead to unintended consequences, such as effectively removing trust without proper checks. Additionally, the function does not validate that the `borrower_` address is not a zero address before proceeding with the trust update.\n\nRecommended Mitigation:\n1. Add a check to ensure `trustAmount` is greater than zero.\n2. Add a check to ensure `borrower_` is not a zero address before proceeding with the trust update.\n'''\n\nLACK OF INPUT VALIDATION IN `debtWriteOff` FUNCTION\n'''\nThe `debtWriteOff` function does not validate that the `amount` parameter is greater than zero before proceeding with the debt write-off process. This could allow a user to attempt to write off a debt of zero, which may not be the intended behavior.\n\nRecommended Mitigation:\n1. Ensure that `amount` is greater than zero before proceeding with the debt write-off logic.\n'''\n\nLACK OF INPUT VALIDATION IN `registerMember` FUNCTION\n'''\nThe `registerMember` function does not validate that the `newMember` address is not a zero address before proceeding with the registration process. This could lead to unintended behavior if a zero address is passed as a new member.\n\nRecommended Mitigation:\n1. Add a check to ensure `newMember` is not a zero address before proceeding with the registration.\n'''\n\nLACK OF INPUT VALIDATION IN `cancelVouch` FUNCTION\n'''\nThe `cancelVouch` function does not validate that the `staker` and `borrower` addresses are not zero addresses before proceeding with the cancellation of the vouch. This could lead to unintended behavior if zero addresses are passed.\n\nRecommended Mitigation:\n1. Add checks to ensure both `staker` and `borrower` are not zero addresses before proceeding with the cancellation logic.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-05-08 22:21:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | //SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""; import ""../Controller.sol""; import ""../interfaces/IAssetManager.sol""; import ""../interfaces/ICreditLimitModel.sol""; import ""../interfaces/IUserManager.sol""; import ""../interfaces/IComptroller.sol""; import ""../interfaces/IUnionToken.sol""; import ""../interfaces/IDai.sol""; import ""../interfaces/IUToken.sol""; /*  * @title UserManager Contract  * @dev Manages the Union members credit lines, and their vouchees and borrowers info.  / contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable; struct Member {     bool isMember;     CreditLine creditLine; }  //address: member address, uint256: trustAmount struct CreditLine {     mapping(address =&gt; uint256) borrowers;     address[] borrowerAddresses;     mapping(address =&gt; uint256) stakers;     address[] stakerAddresses;     mapping(address =&gt; uint256) lockedAmount; }  struct TrustInfo {     address[] stakerAddresses;     address[] borrowerAddresses;     uint256 effectiveCount;     address staker;     uint256 vouchingAmount;     uint256 stakingAmount;     uint256 availableStakingAmount;     uint256 lockedStake;     uint256 totalLockedStake; }  uint256 public constant MAX_TRUST_LIMIT = 100; uint256 public constant MAX_STAKE_AMOUNT = 1000e18; address public stakingToken; address public unionToken; address public assetManager; IUToken public uToken; ICreditLimitModel public creditLimitModel; IComptroller public comptroller; uint256 public newMemberFee; // New member application fee  // slither-disable-next-line constable-states uint256 public override totalStaked; // slither-disable-next-line constable-states uint256 public override totalFrozen; mapping(address =&gt; Member) private members; // slither-disable-next-line uninitialized-state mapping(address =&gt; uint256) public stakers; //1 user address 2 amount mapping(address =&gt; uint256) public memberFrozen; //1 user address 2 frozen amount  modifier onlyMember(address account) {     require(checkIsMember(account), ""UserManager: caller does not have the Member role"");     _; }  modifier onlyMarketOrAdmin() {     require(         address(uToken) == msg.sender || isAdmin(msg.sender),         ""UserManager: caller does not the market or admin""     );     _; }  /**  *  @dev Update new credit limit model event  *  @param newCreditLimitModel New credit limit model address  */ event LogNewCreditLimitModel(address newCreditLimitModel);  /**  *  @dev Add new member event  *  @param member New member address  */ event LogAddMember(address member);  /**  *  @dev Update vouch for existing member event  *  @param staker Trustee address  *  @param borrower The address gets vouched for  *  @param trustAmount Vouch amount  */ event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);  /**  *  @dev New member application event  *  @param account New member's voucher address  *  @param borrower New member address  */ event LogRegisterMember(address indexed account, address indexed borrower);  /**  *  @dev Cancel vouching for other member event  *  @param account New member's voucher address  *  @param borrower The address gets vouched for  */ event LogCancelVouch(address indexed account, address indexed borrower);  /**  *  @dev Stake event  *  @param account The staker's address  *  @param amount The amount of tokens to stake  */ event LogStake(address indexed account, uint256 amount);  /**  *  @dev Unstake event  *  @param account The staker's address  *  @param amount The amount of tokens to unstake  */ event LogUnstake(address indexed account, uint256 amount);  /**  *  @dev DebtWriteOff event  *  @param staker The staker's address  *  @param borrower The borrower's address  *  @param amount The amount of write off  */ event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);  function __UserManager_init(     address assetManager_,     address unionToken_,     address stakingToken_,     address creditLimitModel_,     address comptroller_,     address admin_ ) public initializer {     Controller.__Controller_init(admin_);     ReentrancyGuardUpgradeable.__ReentrancyGuard_init();     _setCreditLimitModel(creditLimitModel_);     comptroller = IComptroller(comptroller_);     assetManager = assetManager_;     unionToken = unionToken_;     stakingToken = stakingToken_;     newMemberFee = 10**18; // Set the default membership fee }  function setUToken(address uToken_) public onlyAdmin {     uToken = IUToken(uToken_); }  function setNewMemberFee(uint256 amount) public onlyAdmin {     newMemberFee = amount; }  /**  *  @dev Change the credit limit model  *  Accept claims only from the admin  *  @param newCreditLimitModel New credit limit model address  */ function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {     _setCreditLimitModel(newCreditLimitModel); }  function _setCreditLimitModel(address newCreditLimitModel) private {     require(         ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),         ""MemberMnager: new model is not a creditLimitModel""     );     creditLimitModel = ICreditLimitModel(newCreditLimitModel);      emit LogNewCreditLimitModel(newCreditLimitModel); }  /**  *  @dev Check if the account is a valid member  *  @param account Member address  *  @return Address whether is member  */ function checkIsMember(address account) public view override returns (bool) {     return members[account].isMember; }  /**  *  @dev Get member borrowerAddresses  *  @param account Member address  *  @return Address array  */ function getBorrowerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.borrowerAddresses; }  /**  *  @dev Get member stakerAddresses  *  @param account Member address  *  @return Address array  */ function getStakerAddresses(address account) public view override returns (address[] memory) {     return members[account].creditLine.stakerAddresses; }  /**  *  @dev Get member backer asset  *  @param account Member address  *  @param borrower Borrower address  *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount  */ function getBorrowerAsset(address account, address borrower)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.borrowers[borrower];     lockedStake = getLockedStake(account, borrower);     vouchingAmount = getVouchingAmount(account, borrower); }  /**  *  @dev Get member stakers asset  *  @param account Member address  *  @param staker Staker address  *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake  */ function getStakerAsset(address account, address staker)     public     view     override     returns (         uint256 trustAmount,         uint256 vouchingAmount,         uint256 lockedStake     ) {     trustAmount = members[account].creditLine.stakers[staker];     lockedStake = getLockedStake(staker, account);     vouchingAmount = getVouchingAmount(staker, account); }  /**  *  @dev Get staker locked stake for a borrower  *  @param staker Staker address  *  @param borrower Borrower address  *  @return LockedStake  */ function getLockedStake(address staker, address borrower) public view returns (uint256) {     return members[staker].creditLine.lockedAmount[borrower]; }  /**  *  @dev Get the user's locked stake from all his backed loans  *  @param staker Staker address  *  @return LockedStake  */ function getTotalLockedStake(address staker) public view override returns (uint256) {     uint256 totalLockedStake = 0;     uint256 stakingAmount = stakers[staker];     address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;     address borrower;     for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         borrower = borrowerAddresses[i];         totalLockedStake += getLockedStake(staker, borrower);     }      if (stakingAmount &gt;= totalLockedStake) {         return totalLockedStake;     } else {         return stakingAmount;     } }  /**  *  @dev Get staker's defaulted / frozen staked token amount  *  @param staker Staker address  *  @return Frozen token amount  */ function getTotalFrozenAmount(address staker) public view override returns (uint256) {     TrustInfo memory trustInfo;     uint256 totalFrozenAmount = 0;     trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;     trustInfo.stakingAmount = stakers[staker];      address borrower;     for (uint256 i = 0; i &lt; trustInfo.borrowerAddresses.length; i++) {         borrower = trustInfo.borrowerAddresses[i];         if (uToken.checkIsOverdue(borrower)) {             totalFrozenAmount += getLockedStake(staker, borrower);         }     }      if (trustInfo.stakingAmount &gt;= totalFrozenAmount) {         return totalFrozenAmount;     } else {         return trustInfo.stakingAmount;     } }  /**  *  @dev Get the member's available credit line  *  @param borrower Member address  *  @return Credit line amount  */ function getCreditLimit(address borrower) public view override returns (int256) {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     // Get the number of effective vouchee, first     trustInfo.effectiveCount = 0;     uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         trustInfo.staker = trustInfo.stakerAddresses[i];          trustInfo.stakingAmount = stakers[trustInfo.staker];          trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit         if (trustInfo.vouchingAmount &gt; 0) {             //availableStakingAmount is staker‘s free stake amount             trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);              trustInfo.availableStakingAmount = trustInfo.stakingAmount;             uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);             if (trustInfo.stakingAmount &lt;= totalLockedStake) {                 trustInfo.availableStakingAmount = 0;             } else {                 trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;             }              trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);              require(                 trustInfo.vouchingAmount &gt;= trustInfo.lockedStake,                 ""UserManager: vouchingAmount or lockedStake data error""             );              //The actual effective guarantee amount cannot exceed availableStakingAmount,             if (trustInfo.vouchingAmount &gt;= trustInfo.availableStakingAmount + trustInfo.lockedStake) {                 limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;             } else {                 if (trustInfo.vouchingAmount &lt;= trustInfo.lockedStake) {                     limits[trustInfo.effectiveCount] = 0;                 } else {                     limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;                 }             }             trustInfo.effectiveCount += 1;         }     }      uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);     for (uint256 j = 0; j &lt; trustInfo.effectiveCount; j++) {         creditlimits[j] = limits[j];     }      return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower)); }  /**  *  @dev Get vouching amount  *  @param staker Staker address  *  @param borrower Borrower address  */ function getVouchingAmount(address staker, address borrower) public view returns (uint256) {     uint256 totalStake = stakers[staker];     uint256 trustAmount = members[borrower].creditLine.stakers[staker];     if (trustAmount &gt; totalStake) {         return totalStake;     } else {         return trustAmount;     } }  /**  *  @dev Get the user's deposited stake amount  *  @param account Member address  *  @return Deposited stake amount  */ function getStakerBalance(address account) public view override returns (uint256) {     return stakers[account]; }  /**  *  @dev Add member  *  Accept claims only from the admin  *  @param account Member address  */ function addMember(address account) public override onlyAdmin {     require(!checkIsMember(account), ""UserManager: address is already member"");     members[account].isMember = true;     emit LogAddMember(account); }  /**  *  @dev Update the trust amount for exisitng members.  *  @param borrower_ Account address  *  @param trustAmount Trust amount  */ function updateTrust(address borrower_, uint256 trustAmount)     external     override     onlyMember(msg.sender)     whenNotPaused {     require(borrower_ != address(0), ""borrower cannot be zero"");     address borrower = borrower_;      TrustInfo memory trustInfo;     trustInfo.staker = msg.sender;     require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");     require(         members[borrower].creditLine.stakerAddresses.length &lt; MAX_TRUST_LIMIT &amp;&amp;             members[trustInfo.staker].creditLine.borrowerAddresses.length &lt; MAX_TRUST_LIMIT,         ""UserManager: trust reach limit""     );     trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;     trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);     require(         trustAmount &gt;= trustInfo.lockedStake,         ""UserManager: trust amount cannot be less than the locked amount ""     );     uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (trustInfo.borrowerAddresses[i] == borrower) {             borrowerExist = true;         }     }      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (trustInfo.stakerAddresses[i] == trustInfo.staker) {             stakerExist = true;         }     }      if (!borrowerExist) {         members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);     }      if (!stakerExist) {         members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);     }      members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;     members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;     emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount); }  /**  *  @dev Stop vouch for other member.  *  @param staker Staker address  *  @param borrower borrower address  */ function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {     require(         msg.sender == staker || msg.sender == borrower,         ""UserManager: Accept claims only from the staker or borrower""     );      require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");      uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;     bool stakerExist = false;     uint256 stakerIndex = 0;     for (uint256 i = 0; i &lt; stakerCount; i++) {         if (members[borrower].creditLine.stakerAddresses[i] == staker) {             stakerExist = true;             stakerIndex = i;         }     }      uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;     bool borrowerExist = false;     uint256 borrowerIndex = 0;     for (uint256 i = 0; i &lt; borrowerCount; i++) {         if (members[staker].creditLine.borrowerAddresses[i] == borrower) {             borrowerExist = true;             borrowerIndex = i;         }     }      //delete address     if (borrowerExist) {         members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[             borrowerCount - 1         ];         members[staker].creditLine.borrowerAddresses.pop();     }      if (stakerExist) {         members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[             stakerCount - 1         ];         members[borrower].creditLine.stakerAddresses.pop();     }      delete members[staker].creditLine.borrowers[borrower];     delete members[borrower].creditLine.stakers[staker];      emit LogCancelVouch(staker, borrower); }  function registerMemberWithPermit(     address newMember,     uint256 value,     uint256 deadline,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);     registerMember(newMember); }  /**  *  @dev Apply for membership, and burn UnionToken as application fees  *  @param newMember New member address  */ function registerMember(address newMember) public override whenNotPaused {     IUnionToken unionTokenContract = IUnionToken(unionToken);     require(!checkIsMember(newMember), ""UserManager: address is already member"");     require(unionTokenContract.balanceOf(msg.sender) &gt;= newMemberFee, ""UserManager: balance not enough"");      uint256 effectiveStakerNumber = 0;     for (uint256 i = 0; i &lt; members[newMember].creditLine.stakerAddresses.length; i++) {         address stakerAddress = members[newMember].creditLine.stakerAddresses[i];         if (checkIsMember(stakerAddress) &amp;&amp; getVouchingAmount(stakerAddress, newMember) &gt; 0)             effectiveStakerNumber += 1;     }      require(         effectiveStakerNumber &gt;= creditLimitModel.effectiveNumber(),         ""UserManager: not enough effective stakers""     );      members[newMember].isMember = true;      unionTokenContract.burnFrom(msg.sender, newMemberFee);      emit LogRegisterMember(msg.sender, newMember); }  function updateLockedData(     address borrower,     uint256 amount,     bool isBorrow ) external override onlyMarketOrAdmin {     TrustInfo memory trustInfo;     trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;      ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](         trustInfo.stakerAddresses.length     );      for (uint256 i = 0; i &lt; trustInfo.stakerAddresses.length; i++) {         ICreditLimitModel.LockedInfo memory lockedInfo;          trustInfo.staker = trustInfo.stakerAddresses[i];         trustInfo.stakingAmount = stakers[trustInfo.staker];         trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);          trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);         if (trustInfo.stakingAmount &lt;= trustInfo.totalLockedStake) {             trustInfo.availableStakingAmount = 0;         } else {             trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;         }          lockedInfo.staker = trustInfo.staker;         lockedInfo.vouchingAmount = trustInfo.vouchingAmount;         lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);         lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;          lockedInfoList[i] = lockedInfo;     }      for (uint256 i = 0; i &lt; lockedInfoList.length; i++) {         members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(             lockedInfoList,             lockedInfoList[i].staker,             amount,             isBorrow         );     } }  /**  *  @dev Stake  *  @param amount Amount  */ function stake(uint256 amount) public override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);      comptroller.withdrawRewards(msg.sender, stakingToken);      uint256 balance = stakers[msg.sender];      require(balance + amount &lt;= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");      stakers[msg.sender] = balance + amount;     totalStaked += amount;      require(         erc20Token.allowance(msg.sender, address(this)) &gt;= amount,         ""UserManager: not enough allowance to stake""     );     erc20Token.safeTransferFrom(msg.sender, address(this), amount);     erc20Token.safeApprove(assetManager, 0);     erc20Token.safeApprove(assetManager, amount);      require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");      emit LogStake(msg.sender, amount); }  /**  *  @dev stakeWithPermit  *  @param amount Amount  */ function stakeWithPermit(     uint256 amount,     uint256 nonce,     uint256 expiry,     uint8 v,     bytes32 r,     bytes32 s ) public whenNotPaused {     IDai erc20Token = IDai(stakingToken);     erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);      stake(amount); }  /**  *  @dev Unstake  *  @param amount Amount  */ function unstake(uint256 amount) external override whenNotPaused nonReentrant {     IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);     uint256 stakingAmount = stakers[msg.sender];     require(         stakingAmount - getTotalLockedStake(msg.sender) &gt;= amount,         ""UserManager: unstake balance is insufficient""     );      comptroller.withdrawRewards(msg.sender, stakingToken);      stakers[msg.sender] = stakingAmount - amount;     totalStaked -= amount;      require(         IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),         ""UserManager: withdraw failed""     );      erc20Token.safeTransfer(msg.sender, amount);      emit LogUnstake(msg.sender, amount); }  function withdrawRewards() external whenNotPaused nonReentrant {     uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);     require(rewards &gt; 0, ""UserManager: not enough rewards""); }  /**  *  @dev Repay user's loan overdue, called only from the lending market  *  @param account User address  *  @param token The asset token repaying to  *  @param lastRepay Last repay block number  */ function repayLoanOverdue(     address account,     address token,     uint256 lastRepay ) external override whenNotPaused onlyMarketOrAdmin {     address[] memory stakerAddresses = getStakerAddresses(account);     for (uint256 i = 0; i &lt; stakerAddresses.length; i++) {         address staker = stakerAddresses[i];         (, , uint256 lockedStake) = getStakerAsset(account, staker);          comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);     } }  //Only supports sumOfTrust function debtWriteOff(address borrower, uint256 amount) public {     require(amount &gt; 0, ""UserManager: amount can not be zero"");     require(totalStaked &gt;= amount, ""UserManager: amount exceeds the totalStaked"");     require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");     uint256 lockedAmount = getLockedStake(msg.sender, borrower);     require(lockedAmount &gt;= amount, ""UserManager: amount exceeds the locked amount"");      _updateTotalFrozen(borrower, true);     require(totalFrozen &gt;= amount, ""UserManager: amount exceeds the totalFrozen"");     comptroller.withdrawRewards(msg.sender, stakingToken);      //The borrower is still overdue, do not call comptroller.addFrozenCoinAge      stakers[msg.sender] -= amount;     totalStaked -= amount;     totalFrozen -= amount;     if (memberFrozen[borrower] &gt;= amount) {         memberFrozen[borrower] -= amount;     } else {         memberFrozen[borrower] = 0;     }     members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;     uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];     uint256 newTrustAmount = trustAmount - amount;     members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;     members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;     IAssetManager(assetManager).debtWriteOff(stakingToken, amount);     uToken.debtWriteOff(borrower, amount);     emit LogDebtWriteOff(msg.sender, borrower, amount); }  /**  *  @dev Update total frozen  *  @param account borrower address  *  @param isOverdue account is overdue  */ function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     _updateTotalFrozen(account, isOverdue); }  function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)     external     override     onlyMarketOrAdmin     whenNotPaused {     require(accounts.length == isOverdues.length, ""UserManager: params length error"");     require(totalStaked &gt;= totalFrozen, ""UserManager: total stake amount error"");     uint256 effectiveTotalStaked = totalStaked - totalFrozen;     comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);     for (uint256 i = 0; i &lt; accounts.length; i++) {         if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);     } }  function _updateTotalFrozen(address account, bool isOverdue) private {     if (isOverdue) {         //isOverdue = true, user overdue needs to increase totalFrozen          //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated         uint256 amount;         for (uint256 i = 0; i &lt; members[account].creditLine.stakerAddresses.length; i++) {             address staker = members[account].creditLine.stakerAddresses[i];             uint256 lockedStake = getLockedStake(staker, account);             amount += lockedStake;         }          if (memberFrozen[account] == 0) {             //I haven’t updated the frozen amount about this borrower before, just increase the amount directly             totalFrozen += amount;         } else {             //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.             totalFrozen = totalFrozen + amount - memberFrozen[account];         }         //Record the increased value of this borrower this time         memberFrozen[account] = amount;     } else {         //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal         if (totalFrozen &gt; memberFrozen[account]) {             //Minus the frozen amount added last time             totalFrozen -= memberFrozen[account];         } else {             totalFrozen = 0;         }         memberFrozen[account] = 0;     } }  function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);             } else {                 totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);             }         }     }      return totalFrozenCoinAge; }  function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {     uint256 totalFrozenCoinAge = 0;      address[] memory borrowerAddresses = getBorrowerAddresses(staker);      for (uint256 i = 0; i &lt; borrowerAddresses.length; i++) {         address borrower = borrowerAddresses[i];         uint256 blocks = block.number - uToken.getLastRepay(borrower);         if (uToken.checkIsOverdue(borrower)) {             (, , uint256 lockedStake) = getStakerAsset(borrower, staker);              if (pastBlocks &gt;= blocks) {                 totalFrozenCoinAge += lockedStake * blocks;             } else {                 totalFrozenCoinAge += lockedStake * pastBlocks;             }         }     }      return totalFrozenCoinAge; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-05-08 22:21:10 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: //SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is staker‘s free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."".
Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases:
1. When loops have an unbounded iteration count, leading to potential gas exhaustion.
2. When the contract makes external calls that can fail or consume excessive gas.
3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures.
4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion.
2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures.
3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS.
4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics.
If you identify any DoS vulnerabilities, respond with: """,
