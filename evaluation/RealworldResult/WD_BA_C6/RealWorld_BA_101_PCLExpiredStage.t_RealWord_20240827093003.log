[2024-27-08 09:30:03 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827093003)

**Timestamp**: 20240827093003

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}


**project_name**: RealWorld_BA_101_PCLExpiredStage.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827093003.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:30:03 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in expired state',\n            'LP:S1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, 'principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');\n\n        try _user.close(_id) {\n            revert('Cannot go through when entire debt is repaid');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C1');\n        }\n    }\n\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');\n    }\n\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');\n    }\n\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a expired PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot borrow a PCL in expired state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n\n        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);\n        log_named_address('borrower', address(borrower));\n\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            log_named_string('Error', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);\n    }\n\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n\n        try borrower.repay(requestId, 104) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP2');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n\n        assert_repayment_functionality_in_expired_state(requestId, 1010, 'PCL:REP4', borrower);\n    }\n\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);\n    }\n\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));\n    }\n\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw collateral in expired state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw zero collateral in expired state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Admin cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Borrower cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Lender cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL3'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            'If under defaultsAt time period, must not go through',\n            'PCL:L3'\n        );\n    }\n\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:IWLC1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without liquidating the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been expired or not\n\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:03 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:03 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:30:07 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:07 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19796
completion_tokens: 1
total_tokens: 19797
cost: $-1.000000


[2024-27-08 09:30:07 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Let's

[2024-27-08 09:30:08 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 requestId;\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n        // Borrower decides to repay everything at mid-duration\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n    }\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, \'Admin cannot start a PCL in expired state\', \'LP:S1\');\n    }\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, \'Borrower cannot start a PCL in expired state\', \'LP:S1\');\n    }\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot start a PCL in expired state\',\n            \'LP:S1\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, \'Admin cannot Cancel a PCL in expired state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, \'Borrower cannot Cancel a PCL in expired state\', \'PCL:CR1\');\n    }\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot Cancel a PCL in expired state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, \'principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n        try _user.close(_id) {\n            revert(\'Cannot go through when entire debt is repaid\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C1\');\n        }\n    }\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, \'Admin cannot close a expired PCL\', \'PCL:OCLB1\');\n    }\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, \'Borrower cannot close a expired PCL\', \'PCL:C2\');\n    }\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot close a expired PCL\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Deposit collateral function calls\n    *******************/\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Admin cannot borrow a PCL in expired state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Borrower cannot borrow a PCL in expired state\',\n            \'PCL:IB3\'\n        );\n    }\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Lender cannot borrow a PCL in expired state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        log_named_uint(\'Admin Borrow Asset Balance\', _adminBorrowAssetBalance);\n        log_named_address(\'borrower\', address(borrower));\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string(\'Repayment successful\');\n        } catch Error(string memory reason) {\n            log_named_string(\'Error\', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, \'PCL:REP1\', borrower);\n    }\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n        try borrower.repay(requestId, 104) {\n            log_string(\'Repayment successful\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:REP2\');\n        }\n    }\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n        assert_repayment_functionality_in_expired_state(requestId, 1010, \'PCL:REP4\', borrower);\n    }\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, \'\', admin);\n    }\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, \'\', PCLUser(lenders[0].lenderAddress));\n    }\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, \'\', borrower);\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Admin cannot withdraw collateral in expired state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Borrower cannot withdraw collateral in expired state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Borrower cannot withdraw zero collateral in expired state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Lender cannot withdraw collateral in expired state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            \'Admin cannot withdraw liquidity a PCL in expired state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            \'Borrower cannot withdraw liquidity a PCL in expired state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            \'Lender cannot withdraw liquidity a PCL in expired state\',\n            \'LP:IWL3\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, \'Admin cannot liquidate an expired PCL\', \'LP:LIQ1\');\n    }\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, \'Borrower cannot liquidate an expired PCL\', \'LP:LIQ1\');\n    }\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            \'If under defaultsAt time period, must not go through\',\n            \'PCL:L3\'\n        );\n    }\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, \'\', \'\');\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, \'\', \'\');\n    }\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n        assert_terminate_functionality_in_expired_state(requestId, admin, \'\', \'\');\n    }\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            \'Cannot terminate a PCL that is expired\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Cannot terminate a PCL that is expired\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert(\'REVERT\');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            \'ERC1155: transfer to the zero address\'\n        );\n    }\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            \'LP:IT1\'\n        );\n    }\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            \'LP:IT3\'\n        );\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            \'LP:IT2\'\n        );\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            \'LP:IT5\'\n        );\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, \'LP:WI1\');\n    }\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, \'LP:WI1\');\n    }\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), \'\');\n    }\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw zero interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            \'Cannot withdraw liquidation/liquidity from an expired PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            \'Cannot withdraw liquidation/liquidity from an expired PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Cannot withdraw liquidation/liquidity from an expired PCL\',\n            \'LP:IWLC1\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert(\'Cannot be called without liquidating the borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn\'t matter whether the PCL has been expired or not\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 requestId;\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n        // Borrower decides to repay everything at mid-duration\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n    }\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, \'Admin cannot start a PCL in expired state\', \'LP:S1\');\n    }\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, \'Borrower cannot start a PCL in expired state\', \'LP:S1\');\n    }\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot start a PCL in expired state\',\n            \'LP:S1\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, \'Admin cannot Cancel a PCL in expired state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, \'Borrower cannot Cancel a PCL in expired state\', \'PCL:CR1\');\n    }\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot Cancel a PCL in expired state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, \'principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n        try _user.close(_id) {\n            revert(\'Cannot go through when entire debt is repaid\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C1\');\n        }\n    }\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, \'Admin cannot close a expired PCL\', \'PCL:OCLB1\');\n    }\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, \'Borrower cannot close a expired PCL\', \'PCL:C2\');\n    }\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot close a expired PCL\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Deposit collateral function calls\n    *******************/\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Admin cannot borrow a PCL in expired state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Borrower cannot borrow a PCL in expired state\',\n            \'PCL:IB3\'\n        );\n    }\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Lender cannot borrow a PCL in expired state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        log_named_uint(\'Admin Borrow Asset Balance\', _adminBorrowAssetBalance);\n        log_named_address(\'borrower\', address(borrower));\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string(\'Repayment successful\');\n        } catch Error(string memory reason) {\n            log_named_string(\'Error\', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, \'PCL:REP1\', borrower);\n    }\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n        try borrower.repay(requestId, 104) {\n            log_string(\'Repayment successful\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:REP2\');\n        }\n    }\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n        assert_repayment_functionality_in_expired_state(requestId, 1010, \'PCL:REP4\', borrower);\n    }\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, \'\', admin);\n    }\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, \'\', PCLUser(lenders[0].lenderAddress));\n    }\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint(\'Current debt\', _currentDebt);\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, \'\', borrower);\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Admin cannot withdraw collateral in expired state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Borrower cannot withdraw collateral in expired state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Borrower cannot withdraw zero collateral in expired state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            \'Lender cannot withdraw collateral in expired state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            \'Admin cannot withdraw liquidity a PCL in expired state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            \'Borrower cannot withdraw liquidity a PCL in expired state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            \'Lender cannot withdraw liquidity a PCL in expired state\',\n            \'LP:IWL3\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, \'Admin cannot liquidate an expired PCL\', \'LP:LIQ1\');\n    }\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, \'Borrower cannot liquidate an expired PCL\', \'LP:LIQ1\');\n    }\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            \'If under defaultsAt time period, must not go through\',\n            \'PCL:L3\'\n        );\n    }\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, \'\', \'\');\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, \'\', \'\');\n    }\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n        assert_terminate_functionality_in_expired_state(requestId, admin, \'\', \'\');\n    }\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            \'Cannot terminate a PCL that is expired\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Cannot terminate a PCL that is expired\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert(\'REVERT\');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            \'ERC1155: transfer to the zero address\'\n        );\n    }\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            \'LP:IT1\'\n        );\n    }\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            \'LP:IT3\'\n        );\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            \'LP:IT2\'\n        );\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            \'LP:IT5\'\n        );\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, \'LP:WI1\');\n    }\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, \'LP:WI1\');\n    }\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), \'\');\n    }\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw zero interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            \'Cannot withdraw liquidation/liquidity from an expired PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            \'Cannot withdraw liquidation/liquidity from an expired PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Cannot withdraw liquidation/liquidity from an expired PCL\',\n            \'LP:IWLC1\'\n        );\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert(\'Cannot be called without liquidating the borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn\'t matter whether the PCL has been expired or not\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:08 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:08 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 requestId;
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);
        // Borrower decides to repay everything at mid-duration
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);
        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }
    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }
    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }
    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }
    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);
        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);
        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');
        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }
    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }
    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }
    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }
    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/
    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }
    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }
    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }
    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }
    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));
        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }
    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }
    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);
        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));
        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }
    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);
        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);
        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }
    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }
    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }
    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }
        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }
    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }
    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }
    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }
    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }
    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }
    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));
        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);
            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }
    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }
    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }
    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }
    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;
    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;
    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);
        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);
            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);
            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));
            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);
            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));
            helper_timeWarp(block.timestamp + request.defaultGracePeriod);
            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);
            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);
            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);
            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }
    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }
    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }
    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }
    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);
        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);
        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));
        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);
            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }
            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }
    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }
    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }
    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);
        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);
        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }
    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }
    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);
        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited
        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state
        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited
        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED
        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not
        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }
    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }
    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 requestId;
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);
        // Borrower decides to repay everything at mid-duration
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);
        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }
    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }
    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }
    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }
    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);
        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);
        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');
        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }
    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }
    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }
    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }
    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/
    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }
    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }
    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }
    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }
    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));
        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }
    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }
    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);
        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));
        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }
    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);
        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);
        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }
    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }
    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }
    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);
        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }
        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }
    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }
    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }
    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }
    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }
    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }
    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));
        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);
            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }
    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }
    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }
    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }
    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;
    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;
    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);
        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);
            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);
            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));
            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);
            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));
            helper_timeWarp(block.timestamp + request.defaultGracePeriod);
            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);
            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);
            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);
            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }
    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }
    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }
    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }
    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);
        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);
        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));
        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);
            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }
            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }
    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }
    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }
    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);
        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);
        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }
    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }
    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);
        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited
        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state
        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited
        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED
        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not
        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }
    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }
    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:30:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 29741
completion_tokens: 1
total_tokens: 29742
cost: $-1.000000


[2024-27-08 09:30:11 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Security

[2024-27-08 09:30:11 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:30:11 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:30:11 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:30:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in expired state',\n            'LP:S1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, 'principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');\n\n        try _user.close(_id) {\n            revert('Cannot go through when entire debt is repaid');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C1');\n        }\n    }\n\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');\n    }\n\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');\n    }\n\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a expired PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot borrow a PCL in expired state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n\n        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);\n        log_named_address('borrower', address(borrower));\n\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            log_named_string('Error', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);\n    }\n\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n\n        try borrower.repay(requestId, 104) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP2');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n\n        assert_repayment_functionality_in_expired_state(requestId, 1010, 'PCL:REP4', borrower);\n    }\n\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);\n    }\n\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));\n    }\n\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw collateral in expired state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw zero collateral in expired state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Admin cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Borrower cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Lender cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL3'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            'If under defaultsAt time period, must not go through',\n            'PCL:L3'\n        );\n    }\n\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:IWLC1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without liquidating the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been expired or not\n\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:30:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19787
completion_tokens: 1
total_tokens: 19788
cost: $-1.000000


[2024-27-08 09:30:15 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

###

[2024-27-08 09:30:15 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:30:15 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:30:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:15 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:30:26 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:26 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9953
completion_tokens: 665
total_tokens: 10618
cost: $-1.000000


[2024-27-08 09:30:26 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Based on the provided Solidity smart contract code for the `PCLExpiredStage` contract, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risk**: 
   - The contract allows for multiple functions that involve transferring tokens or changing states, which could be susceptible to reentrancy attacks if not properly guarded. Functions like `withdrawLiquidity`, `repay`, and `liquidate` should implement checks to prevent reentrancy.

2. **Lack of Access Control**:
   - Certain functions, such as `terminate`, `liquidate`, and `withdrawLiquidity`, may not have sufficient access control checks. This could allow unauthorized users to call these functions, potentially leading to loss of funds or manipulation of contract state.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, which mitigates overflow and underflow risks, it is essential to ensure that all arithmetic operations are consistently using `SafeMath` to prevent any potential vulnerabilities.

4. **Improper Error Handling**:
   - The contract relies on `try/catch` for error handling in several functions. If the error messages are not standardized or if the revert reasons are not clear, it could lead to confusion and difficulty in debugging.

5. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. Functions that transfer tokens should check the return value of the transfer functions to ensure that the transfer was successful.

6. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve loops or multiple state changes. This could lead to out-of-gas errors during execution, especially in a complex contract with many interactions.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions with higher gas prices to gain an advantage.

8. **Lack of Event Emissions**:
   - Important state changes, such as collateral deposits, repayments, and liquidations, should emit events to provide transparency and allow for easier tracking of contract activity.

### Comprehensive Analysis Report:

The `PCLExpiredStage` contract exhibits several security vulnerabilities that could potentially compromise the integrity and functionality of the contract. Key areas of concern include reentrancy risks, insufficient access control, and improper error handling, which could lead to unauthorized actions or loss of funds. 

While the use of `SafeMath` mitigates overflow and underflow risks, it is crucial to ensure that all arithmetic operations are consistently protected. Additionally, the contract should implement robust mechanisms to handle token transfer failures and prevent front-running attacks.

To enhance the security posture of the contract, it is recommended to:
- Implement reentrancy guards on critical functions.
- Enforce strict access control measures to sensitive functions.
- Ensure all token transfers are checked for success.
- Standardize error messages and improve event emissions for better tracking.
- Consider gas efficiency in function design to avoid out-of-gas errors.

Overall, addressing these vulnerabilities will significantly improve the security and reliability of the `PCLExpiredStage` contract, ensuring a safer environment for users interacting with the pooled credit line system.

[2024-27-08 09:30:26 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PCLExpiredStage` contract, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risk**: 
   - The contract allows for multiple functions that involve transferring tokens or changing states, which could be susceptible to reentrancy attacks if not properly guarded. Functions like `withdrawLiquidity`, `repay`, and `liquidate` should implement checks to prevent reentrancy.

2. **Lack of Access Control**:
   - Certain functions, such as `terminate`, `liquidate`, and `withdrawLiquidity`, may not have sufficient access control checks. This could allow unauthorized users to call these functions, potentially leading to loss of funds or manipulation of contract state.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, which mitigates overflow and underflow risks, it is essential to ensure that all arithmetic operations are consistently using `SafeMath` to prevent any potential vulnerabilities.

4. **Improper Error Handling**:
   - The contract relies on `try/catch` for error handling in several functions. If the error messages are not standardized or if the revert reasons are not clear, it could lead to confusion and difficulty in debugging.

5. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. Functions that transfer tokens should check the return value of the transfer functions to ensure that the transfer was successful.

6. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve loops or multiple state changes. This could lead to out-of-gas errors during execution, especially in a complex contract with many interactions.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions with higher gas prices to gain an advantage.

8. **Lack of Event Emissions**:
   - Important state changes, such as collateral deposits, repayments, and liquidations, should emit events to provide transparency and allow for easier tracking of contract activity.

### Comprehensive Analysis Report:

The `PCLExpiredStage` contract exhibits several security vulnerabilities that could potentially compromise the integrity and functionality of the contract. Key areas of concern include reentrancy risks, insufficient access control, and improper error handling, which could lead to unauthorized actions or loss of funds. 

While the use of `SafeMath` mitigates overflow and underflow risks, it is crucial to ensure that all arithmetic operations are consistently protected. Additionally, the contract should implement robust mechanisms to handle token transfer failures and prevent front-running attacks.

To enhance the security posture of the contract, it is recommended to:
- Implement reentrancy guards on critical functions.
- Enforce strict access control measures to sensitive functions.
- Ensure all token transfers are checked for success.
- Standardize error messages and improve event emissions for better tracking.
- Consider gas efficiency in function design to avoid out-of-gas errors.

Overall, addressing these vulnerabilities will significantly improve the security and reliability of the `PCLExpiredStage` contract, ensuring a safer environment for users interacting with the pooled credit line system.

[2024-27-08 09:30:26 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:30:26 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in expired state',\n            'LP:S1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, 'principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');\n\n        try _user.close(_id) {\n            revert('Cannot go through when entire debt is repaid');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C1');\n        }\n    }\n\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');\n    }\n\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');\n    }\n\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a expired PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot borrow a PCL in expired state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n\n        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);\n        log_named_address('borrower', address(borrower));\n\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            log_named_string('Error', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);\n    }\n\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n\n        try borrower.repay(requestId, 104) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP2');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n\n        assert_repayment_functionality_in_expired_state(requestId, 1010, 'PCL:REP4', borrower);\n    }\n\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);\n    }\n\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));\n    }\n\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw collateral in expired state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw zero collateral in expired state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Admin cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Borrower cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Lender cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL3'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            'If under defaultsAt time period, must not go through',\n            'PCL:L3'\n        );\n    }\n\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:IWLC1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without liquidating the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been expired or not\n\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:26 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:26 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:30:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19787
completion_tokens: 1
total_tokens: 19788
cost: $-1.000000


[2024-27-08 09:30:32 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

###

[2024-27-08 09:30:32 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:30:32 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:30:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:32 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:30:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9953
completion_tokens: 746
total_tokens: 10699
cost: $-1.000000


[2024-27-08 09:30:42 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Based on the provided smart contract code for the `PCLExpiredStage` and the analysis of its functionality, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risks**: 
   - The contract does not implement any reentrancy guards in functions that involve transferring tokens or updating states. This could allow an attacker to exploit the contract by recursively calling functions before the state is updated.

2. **Lack of Input Validation**:
   - Functions such as `borrow`, `repay`, and `withdrawCollateral` do not adequately validate input parameters. For instance, there are no checks to ensure that the amounts being borrowed or repaid are within acceptable limits or that they do not exceed the user's balance.

3. **Error Handling**:
   - The contract relies heavily on `try/catch` statements for error handling, which can obscure the root cause of failures. This could lead to situations where errors are not properly logged or handled, making debugging difficult.

4. **Access Control Issues**:
   - The contract allows certain actions (like terminating or liquidating a PCL) to be performed by users who may not have the appropriate permissions. For example, the `terminate` function can be called by the admin, but it should also ensure that the admin is the only one who can call it.

5. **Token Transfer Logic**:
   - The logic for transferring tokens does not account for potential failures in the transfer process. If a transfer fails, the contract state may not revert to its previous state, leading to inconsistencies.

6. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially in complex calculations involving multiple variables.

7. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve loops or multiple state changes. This could lead to transactions failing due to exceeding the gas limit.

8. **Lack of Event Emissions**:
   - Important state changes (like borrowing, repaying, or liquidating) do not emit events. This makes it difficult to track the history of actions taken on the contract and could hinder off-chain applications from reacting to state changes.

### Comprehensive Analysis Report:

The `PCLExpiredStage` contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The lack of reentrancy guards, insufficient input validation, and reliance on `try/catch` for error handling are significant concerns that could lead to unexpected behaviors and loss of funds. Additionally, access control issues could allow unauthorized users to perform sensitive actions, further exacerbating the risk.

The token transfer logic must be fortified to ensure that failures are handled gracefully, and the contract should implement proper event emissions to enhance transparency and traceability. While the use of `SafeMath` mitigates some risks associated with integer overflows and underflows, developers should remain vigilant and ensure that all arithmetic operations are handled correctly.

To improve the security posture of the contract, it is recommended to:
- Implement reentrancy guards in critical functions.
- Enhance input validation to ensure that all parameters are within acceptable limits.
- Use more explicit error handling and logging mechanisms to capture failures.
- Review access control mechanisms to ensure that only authorized users can perform sensitive actions.
- Ensure that all token transfers are checked for success and revert the state if they fail.
- Emit events for all significant state changes to improve tracking and monitoring.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting user funds and maintaining trust in the system.

[2024-27-08 09:30:42 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `PCLExpiredStage` and the analysis of its functionality, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risks**: 
   - The contract does not implement any reentrancy guards in functions that involve transferring tokens or updating states. This could allow an attacker to exploit the contract by recursively calling functions before the state is updated.

2. **Lack of Input Validation**:
   - Functions such as `borrow`, `repay`, and `withdrawCollateral` do not adequately validate input parameters. For instance, there are no checks to ensure that the amounts being borrowed or repaid are within acceptable limits or that they do not exceed the user's balance.

3. **Error Handling**:
   - The contract relies heavily on `try/catch` statements for error handling, which can obscure the root cause of failures. This could lead to situations where errors are not properly logged or handled, making debugging difficult.

4. **Access Control Issues**:
   - The contract allows certain actions (like terminating or liquidating a PCL) to be performed by users who may not have the appropriate permissions. For example, the `terminate` function can be called by the admin, but it should also ensure that the admin is the only one who can call it.

5. **Token Transfer Logic**:
   - The logic for transferring tokens does not account for potential failures in the transfer process. If a transfer fails, the contract state may not revert to its previous state, leading to inconsistencies.

6. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially in complex calculations involving multiple variables.

7. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve loops or multiple state changes. This could lead to transactions failing due to exceeding the gas limit.

8. **Lack of Event Emissions**:
   - Important state changes (like borrowing, repaying, or liquidating) do not emit events. This makes it difficult to track the history of actions taken on the contract and could hinder off-chain applications from reacting to state changes.

### Comprehensive Analysis Report:

The `PCLExpiredStage` contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The lack of reentrancy guards, insufficient input validation, and reliance on `try/catch` for error handling are significant concerns that could lead to unexpected behaviors and loss of funds. Additionally, access control issues could allow unauthorized users to perform sensitive actions, further exacerbating the risk.

The token transfer logic must be fortified to ensure that failures are handled gracefully, and the contract should implement proper event emissions to enhance transparency and traceability. While the use of `SafeMath` mitigates some risks associated with integer overflows and underflows, developers should remain vigilant and ensure that all arithmetic operations are handled correctly.

To improve the security posture of the contract, it is recommended to:
- Implement reentrancy guards in critical functions.
- Enhance input validation to ensure that all parameters are within acceptable limits.
- Use more explicit error handling and logging mechanisms to capture failures.
- Review access control mechanisms to ensure that only authorized users can perform sensitive actions.
- Ensure that all token transfers are checked for success and revert the state if they fail.
- Emit events for all significant state changes to improve tracking and monitoring.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting user funds and maintaining trust in the system.

[2024-27-08 09:30:43 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:30:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in expired state',\n            'LP:S1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, 'principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');\n\n        try _user.close(_id) {\n            revert('Cannot go through when entire debt is repaid');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C1');\n        }\n    }\n\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');\n    }\n\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');\n    }\n\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a expired PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot borrow a PCL in expired state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n\n        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);\n        log_named_address('borrower', address(borrower));\n\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            log_named_string('Error', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);\n    }\n\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n\n        try borrower.repay(requestId, 104) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP2');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n\n        assert_repayment_functionality_in_expired_state(requestId, 1010, 'PCL:REP4', borrower);\n    }\n\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);\n    }\n\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));\n    }\n\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw collateral in expired state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw zero collateral in expired state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Admin cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Borrower cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Lender cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL3'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            'If under defaultsAt time period, must not go through',\n            'PCL:L3'\n        );\n    }\n\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:IWLC1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without liquidating the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been expired or not\n\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:43 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:30:46 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:46 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19787
completion_tokens: 1
total_tokens: 19788
cost: $-1.000000


[2024-27-08 09:30:46 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

###

[2024-27-08 09:30:46 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:30:46 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:30:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:30:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:46 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:30:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:30:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9953
completion_tokens: 756
total_tokens: 10709
cost: $-1.000000


[2024-27-08 09:30:58 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Based on the provided Solidity smart contract code for the `PCLExpiredStage` and its associated functionalities, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Lack of Input Validation**:
   - Functions that accept user inputs (like `borrow`, `repay`, `withdraw`, etc.) do not have sufficient checks to validate the inputs. For example, there are no checks to ensure that the amounts being borrowed or repaid are within acceptable limits.

3. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which can obscure the flow of execution and make it harder to track down issues. This can lead to situations where errors are not handled properly, allowing for unexpected states.

4. **Access Control Issues**:
   - Certain functions may not have adequate access control checks, allowing unauthorized users (like non-verified lenders) to perform actions that should be restricted. For instance, the ability to call `liquidate` or `terminate` should be tightly controlled.

5. **Token Transfer Issues**:
   - The contract allows for token transfers without ensuring that the recipient is a valid address. This could lead to tokens being sent to the zero address or other unintended addresses, resulting in loss of funds.

6. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially in complex calculations involving multiple variables.

7. **Lack of Event Emission**:
   - Important state changes (like borrowing, repaying, or liquidating) do not emit events. This lack of transparency can make it difficult to track the contract's activity and can hinder debugging efforts.

8. **Hardcoded Values**:
   - Certain values (like `duration`, `grace period`, etc.) are hardcoded, which can limit the flexibility of the contract and may not be suitable for all use cases. This can also lead to issues if the parameters need to be adjusted post-deployment.

### Comprehensive Analysis Report

The `PCLExpiredStage` contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to potential loss of funds or unintended behavior. The absence of reentrancy guards poses a significant risk, especially in functions that involve token transfers. Input validation is lacking, which could allow users to perform actions that are not logically sound, such as borrowing more than allowed or repaying zero amounts.

Access control mechanisms need to be reinforced to ensure that only authorized users can invoke sensitive functions. The reliance on `try/catch` for error handling can obscure the contract's logic and make it harder to diagnose issues. Additionally, the potential for integer overflow/underflow, despite the use of `SafeMath`, should not be overlooked.

The contract also lacks adequate event emissions for critical state changes, which can hinder transparency and tracking of contract activity. Hardcoded values limit the adaptability of the contract, making it less flexible to changes in business logic or user requirements.

In conclusion, while the `PCLExpiredStage` contract implements a complex set of functionalities, it is essential to address the identified vulnerabilities to enhance its security posture. Implementing best practices such as reentrancy guards, thorough input validation, robust access control, and comprehensive event logging will significantly improve the contract's resilience against attacks and operational issues. Regular audits and updates should be conducted to ensure ongoing security as the contract evolves.

[2024-27-08 09:30:58 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PCLExpiredStage` and its associated functionalities, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Lack of Input Validation**:
   - Functions that accept user inputs (like `borrow`, `repay`, `withdraw`, etc.) do not have sufficient checks to validate the inputs. For example, there are no checks to ensure that the amounts being borrowed or repaid are within acceptable limits.

3. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which can obscure the flow of execution and make it harder to track down issues. This can lead to situations where errors are not handled properly, allowing for unexpected states.

4. **Access Control Issues**:
   - Certain functions may not have adequate access control checks, allowing unauthorized users (like non-verified lenders) to perform actions that should be restricted. For instance, the ability to call `liquidate` or `terminate` should be tightly controlled.

5. **Token Transfer Issues**:
   - The contract allows for token transfers without ensuring that the recipient is a valid address. This could lead to tokens being sent to the zero address or other unintended addresses, resulting in loss of funds.

6. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially in complex calculations involving multiple variables.

7. **Lack of Event Emission**:
   - Important state changes (like borrowing, repaying, or liquidating) do not emit events. This lack of transparency can make it difficult to track the contract's activity and can hinder debugging efforts.

8. **Hardcoded Values**:
   - Certain values (like `duration`, `grace period`, etc.) are hardcoded, which can limit the flexibility of the contract and may not be suitable for all use cases. This can also lead to issues if the parameters need to be adjusted post-deployment.

### Comprehensive Analysis Report

The `PCLExpiredStage` contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to potential loss of funds or unintended behavior. The absence of reentrancy guards poses a significant risk, especially in functions that involve token transfers. Input validation is lacking, which could allow users to perform actions that are not logically sound, such as borrowing more than allowed or repaying zero amounts.

Access control mechanisms need to be reinforced to ensure that only authorized users can invoke sensitive functions. The reliance on `try/catch` for error handling can obscure the contract's logic and make it harder to diagnose issues. Additionally, the potential for integer overflow/underflow, despite the use of `SafeMath`, should not be overlooked.

The contract also lacks adequate event emissions for critical state changes, which can hinder transparency and tracking of contract activity. Hardcoded values limit the adaptability of the contract, making it less flexible to changes in business logic or user requirements.

In conclusion, while the `PCLExpiredStage` contract implements a complex set of functionalities, it is essential to address the identified vulnerabilities to enhance its security posture. Implementing best practices such as reentrancy guards, thorough input validation, robust access control, and comprehensive event logging will significantly improve the contract's resilience against attacks and operational issues. Regular audits and updates should be conducted to ensure ongoing security as the contract evolves.

[2024-27-08 09:31:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 3650 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Expired PCL cannot be started\n    function assert_start_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAnExpiredPCL() public {\n        assert_start_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in expired state',\n            'LP:S1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_adminCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAnExpiredPCL() public {\n        assert_cancel_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal != 0);\n\n        _currentDebt = borrower.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);\n\n        // Borrower wants to repay everything now\n        borrower.repay(_id, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);\n        assertTrue(_principal == 0, 'principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');\n\n        try _user.close(_id) {\n            revert('Cannot go through when entire debt is repaid');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C1');\n        }\n    }\n\n    function test_adminCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');\n    }\n\n    // If the principal != 0\n    function test_borrowerCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');\n    }\n\n    // If the principal == 0\n    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {\n        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);\n    }\n\n    function test_lenderCannotCloseAnExpiredPCL() public {\n        assert_close_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a expired PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCanBeDepositedInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);\n        _depositor.depositCollateral(_id, _amount, false);\n        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);\n    }\n\n    function test_borrowerCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCanDepositCollateral() public {\n        uint256 _amountToDeposit = 100 * (10ERC20(address(collateralAsset)).decimals());\n        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot borrow a PCL in expired state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot borrow a PCL in expired state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Repayment function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_repayment_functionality_in_expired_state(\n        uint256 _id,\n        uint256 _repaymentAmount,\n        string memory _errorMessage,\n        PCLUser _user\n    ) public {\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n\n        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);\n        log_named_address('borrower', address(borrower));\n\n        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n        }\n        try _user.repay(_id, _repaymentAmount) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            log_named_string('Error', reason);\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_borrowerCannotRepayZeroAmount() public {\n        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);\n    }\n\n    function test_borrowerCannotRepayIfDebtIsZero() public {\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));\n        borrower.repay(requestId, _currentDebt);\n\n        // Travelling some more so that interest gets accrued and we do not get PCL:REP3\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // Admin transfers some borrow token to the _user for repayment\n        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));\n\n        try borrower.repay(requestId, 104) {\n            log_string('Repayment successful');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP2');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {\n        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);\n\n        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));\n        borrower.repay(requestId, _interestRemaining);\n\n        assert_repayment_functionality_in_expired_state(requestId, 1010, 'PCL:REP4', borrower);\n    }\n\n    function test_adminCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);\n    }\n\n    function test_lenderCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));\n    }\n\n    function test_borrowerCanRepay() public {\n        // Travelling so that some interest gets accrued\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);\n\n        // Repaying the remaining debt so that current debt == 0\n        _currentDebt = pcl.calculateCurrentDebt(requestId);\n        log_named_uint('Current debt', _currentDebt);\n\n        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInExpiredState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Admin cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw collateral in expired state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Borrower cannot withdraw zero collateral in expired state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInExpiredState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            'Lender cannot withdraw collateral in expired state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Admin cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Borrower cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        assert_withdraw_liquidity_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.EXPIRED),\n            false,\n            'Lender cannot withdraw liquidity a PCL in expired state',\n            'LP:IWL3'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            _user.liquidate(_id, true);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            try _user.liquidate(_id, true) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n            }\n        }\n    }\n\n    function test_adminCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAnExpiredPCL() public {\n        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {\n        assert_liquidate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            false,\n            'If under defaultsAt time period, must not go through',\n            'PCL:L3'\n        );\n    }\n\n    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);\n            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        }\n    }\n\n    function test_adminCanTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {\n        helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);\n\n        // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAnExpiredPCL() public {\n        assert_terminate_functionality_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is expired',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    uint256 _originalPrice;\n    uint256 _modifiedPrice;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_expired_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            // Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            helper_timeWarp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_expired_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount / 10);\n\n        vm.warp(block.timestamp + 100 + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        assert_pool_token_transfer_in_expired_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_expiredState() public {\n        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        _lender.withdrawInterest(requestId);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_expired_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawTokensAfterLiquidation(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            admin,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            borrower,\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidation_expiredState() public {\n        assert_withdraw_liquidation_in_expired_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot withdraw liquidation/liquidity from an expired PCL',\n            'LP:IWLC1'\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentDebt;\n    uint256 _currentCR;\n    uint256 _equivalentCollateral;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n\n    // Test8: Helper Functionalities\n    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        assertGt(_equivalentCollateral, 0);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_currentCR, request.collateralRatio);\n        } // Since a lot of extra collateral was deposited\n\n        // 2. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without liquidating the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n\n        // 3. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state\n\n        // 4. calculateTotalCollateralTokens\n        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);\n        if (request.collateralRatio != 0) {\n            assertGt(_totalCollateral, 0);\n        } // Since a lot of extra collateral was deposited\n\n        // 5. calculateBorrowableAmount\n        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED\n\n        // 6. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been expired or not\n\n        // 7. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertEq(_currentDebt, calculatedCurrentDebt);\n    }\n\n    function test_helperFunctionsInExpiredState() public {\n        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);\n    }\n\n    function helper_timeWarp(uint256 _time) public {\n        vm.warp(_time);\n        vm.roll(_time.div(20));\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:31:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 3650 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Expired PCL cannot be started function assert_start_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1'); }  function test_borrowerCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1'); }  function test_lenderCannotStartAnExpiredPCL() public {     assert_start_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in expired state',         'LP:S1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_adminCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1'); }  function test_lenderCannotCancelAnExpiredPCL() public {     assert_cancel_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in expired state',         'PCL:OCLB1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal != 0);      _currentDebt = borrower.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);      // Borrower wants to repay everything now     borrower.repay(_id, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);     assertTrue(_principal == 0, 'principal != 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');      try _user.close(_id) {         revert('Cannot go through when entire debt is repaid');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C1');     } }  function test_adminCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1'); }  // If the principal != 0 function test_borrowerCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2'); }  // If the principal == 0 function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {     assert_close_functionality_in_expired_state_zero_debt(requestId, borrower); }  function test_lenderCannotCloseAnExpiredPCL() public {     assert_close_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a expired PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCanBeDepositedInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }     uint256 _collateralShares = pcl.depositedCollateralInShares(_id);     _depositor.depositCollateral(_id, _amount, false);     assertGt(pcl.depositedCollateralInShares(_id), _collateralShares); }  function test_borrowerCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCanDepositCollateral() public {     uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());     assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot borrow a PCL in expired state',         'PCL:IB3'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot borrow a PCL in expired state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Repayment function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_repayment_functionality_in_expired_state(     uint256 _id,     uint256 _repaymentAmount,     string memory _errorMessage,     PCLUser _user ) public {     // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));      log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);     log_named_address('borrower', address(borrower));      admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));     }     try _user.repay(_id, _repaymentAmount) {         log_string('Repayment successful');     } catch Error(string memory reason) {         log_named_string('Error', reason);         assertEq(reason, _errorMessage);     } }  function test_borrowerCannotRepayZeroAmount() public {     assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower); }  function test_borrowerCannotRepayIfDebtIsZero() public {     // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));     borrower.repay(requestId, _currentDebt);      // Travelling some more so that interest gets accrued and we do not get PCL:REP3     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // Admin transfers some borrow token to the _user for repayment     uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));      try borrower.repay(requestId, 10**4) {         log_string('Repayment successful');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP2');     } }  function test_borrowerCannotRepayIfInterestAccruedIsZero() public {     uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);      admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));     borrower.repay(requestId, _interestRemaining);      assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower); }  function test_adminCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin); }  function test_lenderCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress)); }  function test_borrowerCanRepay() public {     // Travelling so that some interest gets accrued     helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);      // Repaying the remaining debt so that current debt == 0     _currentDebt = pcl.calculateCurrentDebt(requestId);     log_named_uint('Current debt', _currentDebt);      assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInExpiredState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         'Admin cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw collateral in expired state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         'Borrower cannot withdraw zero collateral in expired state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInExpiredState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         'Lender cannot withdraw collateral in expired state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         admin,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Admin cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Borrower cannot withdraw liquidity a PCL in expired state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidity() public {     assert_withdraw_liquidity_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.EXPIRED),         false,         'Lender cannot withdraw liquidity a PCL in expired state',         'LP:IWL3'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         _user.liquidate(_id, true);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         try _user.liquidate(_id, true) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);         }     } }  function test_adminCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAnExpiredPCL() public {     assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {     assert_liquidate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         false,         'If under defaultsAt time period, must not go through',         'PCL:L3'     ); }  function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);     // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);     // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);         assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } }  function test_adminCanTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {     helper_timeWarp(block.timestamp + request.defaultGracePeriod);      // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);      // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');      assert_terminate_functionality_in_expired_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         borrower,         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAnExpiredPCL() public {     assert_terminate_functionality_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is expired',         'Ownable: caller is not the owner'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp; uint256 _originalPrice; uint256 _modifiedPrice;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_expired_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          // Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          helper_timeWarp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_expiredState() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_expired_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount / 10);      vm.warp(block.timestamp + 100 + request.duration);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      assert_pool_token_transfer_in_expired_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_expiredState() public {     assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      _lender.withdrawInterest(requestId);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_expired_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawTokensAfterLiquidation(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         admin,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         borrower,         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:WLC1'     ); }  function test_lenderCannotWithdrawLiquidation_expiredState() public {     assert_withdraw_liquidation_in_expired_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot withdraw liquidation/liquidity from an expired PCL',         'LP:IWLC1'     ); }  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentDebt; uint256 _currentCR; uint256 _equivalentCollateral; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal;  // Test8: Helper Functionalities function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);     assertGt(_equivalentCollateral, 0);      // 1. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     if (request.collateralRatio != 0) {         assertGt(_currentCR, request.collateralRatio);     } // Since a lot of extra collateral was deposited      // 2. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without liquidating the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     }      // 3. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state      // 4. calculateTotalCollateralTokens     uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);     if (request.collateralRatio != 0) {         assertGt(_totalCollateral, 0);     } // Since a lot of extra collateral was deposited      // 5. calculateBorrowableAmount     uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED      // 6. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been expired or not      // 7. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertEq(_currentDebt, calculatedCurrentDebt); }  function test_helperFunctionsInExpiredState() public {     assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId); }  function helper_timeWarp(uint256 _time) public {     vm.warp(_time);     vm.roll(_time.div(20)); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:31:01 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

