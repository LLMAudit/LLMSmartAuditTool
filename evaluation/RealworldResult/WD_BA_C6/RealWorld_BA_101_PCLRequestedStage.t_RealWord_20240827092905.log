[2024-27-08 09:29:05 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827092905)

**Timestamp**: 20240827092905

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}


**project_name**: RealWorld_BA_101_PCLRequestedStage.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLRequestedStage.t_RealWord_20240827092905.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:29:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\n\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\n\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n\n    /*******************\n    Deposit collateral function tests\n    *******************/\n\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser admin = PCLUser(admin);\n\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    /*******************\n    Cancel function tests\n    *******************/\n\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Close function tests\n    *******************/\n\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Terminate function tests\n    *******************/\n\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    View/Calculation function tests\n    *******************/\n\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:06 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:29:09 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:09 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 21546
completion_tokens: 1
total_tokens: 21547
cost: $-1.000000


[2024-27-08 09:29:09 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Let's

[2024-27-08 09:29:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n    /*******************\n    Deposit collateral function tests\n    *******************/\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        PCLUser admin = PCLUser(admin);\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n    /*******************\n    Cancel function tests\n    *******************/\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    /*******************\n    Close function tests\n    *******************/\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    /*******************\n    Liquidate function tests\n    *******************/\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n    /*******************\n    Repay function tests\n    *******************/\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Terminate function tests\n    *******************/\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    /*******************\n    View/Calculation function tests\n    *******************/\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n    /*******************\n    Deposit collateral function tests\n    *******************/\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        PCLUser admin = PCLUser(admin);\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n    /*******************\n    Cancel function tests\n    *******************/\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    /*******************\n    Close function tests\n    *******************/\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    /*******************\n    Liquidate function tests\n    *******************/\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n    /*******************\n    Repay function tests\n    *******************/\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Terminate function tests\n    *******************/\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        vm.warp(block.timestamp + _travelDuration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n    /*******************\n    View/Calculation function tests\n    *******************/\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        vm.warp(block.timestamp + request.collectionPeriod);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:11 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';
contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }
    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }
    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/
    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);
        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }
    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }
    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }
    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }
    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/
    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);
        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }
    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }
    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }
    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }
    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }
    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        PCLUser lender = PCLUser(lenders[0].lenderAddress);
        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }
    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        PCLUser admin = PCLUser(admin);
        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }
    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }
    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/
    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }
    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }
    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);
        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);
            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }
    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/
    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        if (_positiveCase) {
            _user.start(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }
    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/
    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }
    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }
    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }
    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);
        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);
        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);
        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);
        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);
        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }
    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/
    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }
    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }
    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }
    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }
    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }
    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }
    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }
        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/
    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }
    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }
    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/
    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;
    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }
        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);
        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);
        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);
        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }
        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }
        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));
        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }
    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));
        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }
    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/
    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;
        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + 2 days);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }
        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);
        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }
    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }
    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }
    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }
    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }
    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }
    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);
        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }
    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);
        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        vm.warp(block.timestamp + request.collectionPeriod);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }
    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }
    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }
    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }
    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }
    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);
        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';
contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }
    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }
    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/
    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);
        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }
    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }
    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }
    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }
    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/
    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);
        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }
    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }
    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }
    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }
    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }
    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        PCLUser lender = PCLUser(lenders[0].lenderAddress);
        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }
    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        PCLUser admin = PCLUser(admin);
        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }
    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }
    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/
    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }
    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }
    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);
        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);
            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }
    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/
    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        if (_positiveCase) {
            _user.start(_id);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }
    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }
    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/
    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }
    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }
    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }
    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);
        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);
        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);
        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);
        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);
        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }
    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/
    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }
    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }
    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }
    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }
    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }
    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }
    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }
        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/
    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        vm.warp(block.timestamp + _travelDuration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }
        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }
    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }
    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }
    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }
    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/
    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;
    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }
        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);
        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);
        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);
        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }
        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }
        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));
        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }
    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));
        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }
    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/
    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;
        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + 2 days);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }
        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);
        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }
    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }
    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }
    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }
    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }
    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }
    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);
        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }
    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);
        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);
        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        vm.warp(block.timestamp + request.collectionPeriod);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }
    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }
    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }
    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }
    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }
    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);
        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:29:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 32350
completion_tokens: 1
total_tokens: 32351
cost: $-1.000000


[2024-27-08 09:29:16 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Security

[2024-27-08 09:29:16 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:29:16 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:29:16 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:29:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\n\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\n\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n\n    /*******************\n    Deposit collateral function tests\n    *******************/\n\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser admin = PCLUser(admin);\n\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    /*******************\n    Cancel function tests\n    *******************/\n\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Close function tests\n    *******************/\n\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Terminate function tests\n    *******************/\n\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    View/Calculation function tests\n    *******************/\n\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:16 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:29:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 21537
completion_tokens: 1
total_tokens: 21538
cost: $-1.000000


[2024-27-08 09:29:19 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

###

[2024-27-08 09:29:19 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:29:19 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:29:19 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:19 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:19 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:29:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10828
completion_tokens: 672
total_tokens: 11500
cost: $-1.000000


[2024-27-08 09:29:29 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Based on the provided Solidity smart contract code, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrancy attacks, particularly in functions that involve transferring tokens or changing states. This could allow malicious actors to exploit the contract by calling functions recursively.

2. **Improper Error Handling**:
   - The contract relies heavily on `try/catch` statements for error handling. While this is a valid approach, it may lead to unexpected behaviors if not properly managed. For example, if a revert occurs, it may not always be clear what the state of the contract is afterward.

3. **Lack of Access Control**:
   - Certain functions can be called by any user, including administrative functions that should be restricted to specific roles (e.g., only the borrower should be able to cancel a request). This could lead to unauthorized access and manipulation of contract states.

4. **Token Transfer Issues**:
   - The contract allows for token transfers without sufficient checks on the sender's balance or allowance, which could lead to failed transactions or loss of tokens. Additionally, transferring tokens to the zero address is not handled properly.

5. **State Management Flaws**:
   - The contract may not properly manage state transitions, particularly when moving from one status to another (e.g., from REQUESTED to ACTIVE). This could lead to situations where functions are called in inappropriate states, causing unexpected behaviors.

6. **Lack of Input Validation**:
   - Functions do not adequately validate inputs, such as ensuring that amounts are greater than zero or that they do not exceed certain limits. This could lead to logical errors or exploitation.

7. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there may still be areas where arithmetic operations could lead to overflows or underflows if not properly handled, especially in complex calculations.

8. **Insufficient Testing of Edge Cases**:
   - The tests do not cover all possible edge cases, such as extreme values for amounts or unexpected states. This could lead to vulnerabilities that are not caught during the testing phase.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issues include the potential for reentrancy attacks, improper error handling, and insufficient access control mechanisms. These vulnerabilities could lead to unauthorized access, loss of funds, or unexpected behaviors within the contract.

To mitigate these risks, it is recommended to implement the following measures:

- **Reentrancy Guards**: Use the `ReentrancyGuard` pattern to prevent reentrant calls to critical functions.
- **Access Control**: Implement role-based access control to restrict sensitive functions to authorized users only.
- **Input Validation**: Ensure that all inputs are validated before processing, including checks for zero values and limits.
- **State Management**: Clearly define state transitions and ensure that functions can only be called in appropriate states.
- **Comprehensive Testing**: Expand the testing suite to cover edge cases and ensure that all potential vulnerabilities are addressed.

By addressing these vulnerabilities, the security and reliability of the smart contract can be significantly improved, thereby protecting user funds and maintaining trust in the system.

[2024-27-08 09:29:29 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrancy attacks, particularly in functions that involve transferring tokens or changing states. This could allow malicious actors to exploit the contract by calling functions recursively.

2. **Improper Error Handling**:
   - The contract relies heavily on `try/catch` statements for error handling. While this is a valid approach, it may lead to unexpected behaviors if not properly managed. For example, if a revert occurs, it may not always be clear what the state of the contract is afterward.

3. **Lack of Access Control**:
   - Certain functions can be called by any user, including administrative functions that should be restricted to specific roles (e.g., only the borrower should be able to cancel a request). This could lead to unauthorized access and manipulation of contract states.

4. **Token Transfer Issues**:
   - The contract allows for token transfers without sufficient checks on the sender's balance or allowance, which could lead to failed transactions or loss of tokens. Additionally, transferring tokens to the zero address is not handled properly.

5. **State Management Flaws**:
   - The contract may not properly manage state transitions, particularly when moving from one status to another (e.g., from REQUESTED to ACTIVE). This could lead to situations where functions are called in inappropriate states, causing unexpected behaviors.

6. **Lack of Input Validation**:
   - Functions do not adequately validate inputs, such as ensuring that amounts are greater than zero or that they do not exceed certain limits. This could lead to logical errors or exploitation.

7. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there may still be areas where arithmetic operations could lead to overflows or underflows if not properly handled, especially in complex calculations.

8. **Insufficient Testing of Edge Cases**:
   - The tests do not cover all possible edge cases, such as extreme values for amounts or unexpected states. This could lead to vulnerabilities that are not caught during the testing phase.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issues include the potential for reentrancy attacks, improper error handling, and insufficient access control mechanisms. These vulnerabilities could lead to unauthorized access, loss of funds, or unexpected behaviors within the contract.

To mitigate these risks, it is recommended to implement the following measures:

- **Reentrancy Guards**: Use the `ReentrancyGuard` pattern to prevent reentrant calls to critical functions.
- **Access Control**: Implement role-based access control to restrict sensitive functions to authorized users only.
- **Input Validation**: Ensure that all inputs are validated before processing, including checks for zero values and limits.
- **State Management**: Clearly define state transitions and ensure that functions can only be called in appropriate states.
- **Comprehensive Testing**: Expand the testing suite to cover edge cases and ensure that all potential vulnerabilities are addressed.

By addressing these vulnerabilities, the security and reliability of the smart contract can be significantly improved, thereby protecting user funds and maintaining trust in the system.

[2024-27-08 09:29:29 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:29:29 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\n\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\n\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n\n    /*******************\n    Deposit collateral function tests\n    *******************/\n\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser admin = PCLUser(admin);\n\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    /*******************\n    Cancel function tests\n    *******************/\n\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Close function tests\n    *******************/\n\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Terminate function tests\n    *******************/\n\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    View/Calculation function tests\n    *******************/\n\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:29 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:29 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:29:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 21537
completion_tokens: 1
total_tokens: 21538
cost: $-1.000000


[2024-27-08 09:29:32 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

###

[2024-27-08 09:29:32 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:29:32 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:29:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:32 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:29:44 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:44 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10828
completion_tokens: 751
total_tokens: 11579
cost: $-1.000000


[2024-27-08 09:29:44 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Based on the provided Solidity smart contract code and the analysis reports, the following security vulnerabilities have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrant calls, particularly in functions that handle external calls (e.g., lending and withdrawing). This could allow malicious actors to exploit the contract by calling functions recursively before the previous execution completes.

2. **Improper Access Control**:
   - Certain functions (like `terminate`, `start`, and `cancel`) can be called by unauthorized users (e.g., lenders or admins) when they should be restricted to specific roles (e.g., only the borrower). This could lead to unauthorized actions being taken on the pooled credit line.

3. **Lack of Input Validation**:
   - Functions that accept user inputs (like amounts to lend or withdraw) do not adequately validate these inputs. For example, lending zero amounts or amounts exceeding the borrow limit could lead to unexpected behavior or state changes.

4. **State Manipulation**:
   - The contract allows state changes based on conditions that can be manipulated by external actors, such as the timing of state transitions (e.g., moving from REQUESTED to ACTIVE). This could lead to scenarios where the contract behaves unexpectedly.

5. **Insufficient Error Handling**:
   - The contract relies on revert statements without providing detailed error messages in some cases. This can make it difficult to diagnose issues during execution and could lead to confusion for users interacting with the contract.

6. **Token Transfer Issues**:
   - There are checks in place to prevent transferring LP tokens to non-verified users, but the logic could be bypassed if the verification mechanism is flawed or if an attacker finds a way to exploit the transfer functions.

7. **Potential Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to overflow or underflow if not properly handled, especially in complex calculations involving user balances and limits.

8. **Lack of Event Emission**:
   - Certain critical state changes do not emit events, which can hinder tracking and auditing of contract activities. Events should be emitted for actions like lending, withdrawing, and state transitions to ensure transparency.

### Comprehensive Analysis Report:

The smart contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to unauthorized access, loss of funds, or unexpected behavior. The primary concerns revolve around reentrancy attacks, improper access control, and insufficient input validation. 

To mitigate these vulnerabilities, the following recommendations are proposed:

- **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to prevent reentrant calls on critical functions that involve external calls.
  
- **Enhance Access Control**: Utilize role-based access control mechanisms to ensure that only authorized users can execute sensitive functions. Consider using OpenZeppelin's `Ownable` or `AccessControl` contracts.

- **Validate Inputs Rigorously**: Ensure that all user inputs are validated before processing. This includes checks for zero values, negative values, and amounts exceeding predefined limits.

- **Improve Error Handling**: Provide more descriptive error messages for revert statements to facilitate easier debugging and user understanding.

- **Emit Events for Critical Actions**: Ensure that all significant state changes and actions are accompanied by event emissions to enhance transparency and traceability.

- **Conduct Regular Audits**: Regularly audit the contract code and its dependencies to identify and address any emerging vulnerabilities or issues.

By addressing these vulnerabilities and implementing the recommended changes, the security posture of the smart contract can be significantly improved, thereby safeguarding user funds and enhancing trust in the system.

[2024-27-08 09:29:44 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and the analysis reports, the following security vulnerabilities have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrant calls, particularly in functions that handle external calls (e.g., lending and withdrawing). This could allow malicious actors to exploit the contract by calling functions recursively before the previous execution completes.

2. **Improper Access Control**:
   - Certain functions (like `terminate`, `start`, and `cancel`) can be called by unauthorized users (e.g., lenders or admins) when they should be restricted to specific roles (e.g., only the borrower). This could lead to unauthorized actions being taken on the pooled credit line.

3. **Lack of Input Validation**:
   - Functions that accept user inputs (like amounts to lend or withdraw) do not adequately validate these inputs. For example, lending zero amounts or amounts exceeding the borrow limit could lead to unexpected behavior or state changes.

4. **State Manipulation**:
   - The contract allows state changes based on conditions that can be manipulated by external actors, such as the timing of state transitions (e.g., moving from REQUESTED to ACTIVE). This could lead to scenarios where the contract behaves unexpectedly.

5. **Insufficient Error Handling**:
   - The contract relies on revert statements without providing detailed error messages in some cases. This can make it difficult to diagnose issues during execution and could lead to confusion for users interacting with the contract.

6. **Token Transfer Issues**:
   - There are checks in place to prevent transferring LP tokens to non-verified users, but the logic could be bypassed if the verification mechanism is flawed or if an attacker finds a way to exploit the transfer functions.

7. **Potential Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to overflow or underflow if not properly handled, especially in complex calculations involving user balances and limits.

8. **Lack of Event Emission**:
   - Certain critical state changes do not emit events, which can hinder tracking and auditing of contract activities. Events should be emitted for actions like lending, withdrawing, and state transitions to ensure transparency.

### Comprehensive Analysis Report:

The smart contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to unauthorized access, loss of funds, or unexpected behavior. The primary concerns revolve around reentrancy attacks, improper access control, and insufficient input validation. 

To mitigate these vulnerabilities, the following recommendations are proposed:

- **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to prevent reentrant calls on critical functions that involve external calls.
  
- **Enhance Access Control**: Utilize role-based access control mechanisms to ensure that only authorized users can execute sensitive functions. Consider using OpenZeppelin's `Ownable` or `AccessControl` contracts.

- **Validate Inputs Rigorously**: Ensure that all user inputs are validated before processing. This includes checks for zero values, negative values, and amounts exceeding predefined limits.

- **Improve Error Handling**: Provide more descriptive error messages for revert statements to facilitate easier debugging and user understanding.

- **Emit Events for Critical Actions**: Ensure that all significant state changes and actions are accompanied by event emissions to enhance transparency and traceability.

- **Conduct Regular Audits**: Regularly audit the contract code and its dependencies to identify and address any emerging vulnerabilities or issues.

By addressing these vulnerabilities and implementing the recommended changes, the security posture of the smart contract can be significantly improved, thereby safeguarding user funds and enhancing trust in the system.

[2024-27-08 09:29:44 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:29:44 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\n\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\n\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n\n    /*******************\n    Deposit collateral function tests\n    *******************/\n\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser admin = PCLUser(admin);\n\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    /*******************\n    Cancel function tests\n    *******************/\n\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Close function tests\n    *******************/\n\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Terminate function tests\n    *******************/\n\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    View/Calculation function tests\n    *******************/\n\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:44 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:44 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:29:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 21537
completion_tokens: 1
total_tokens: 21538
cost: $-1.000000


[2024-27-08 09:29:48 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

###

[2024-27-08 09:29:48 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:29:48 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:29:48 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:29:48 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:48 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:29:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10828
completion_tokens: 702
total_tokens: 11530
cost: $-1.000000


[2024-27-08 09:29:58 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Based on the provided smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement a proper reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, leading to unexpected behaviors or loss of funds.

2. **Improper Access Control**:
   - Functions that should be restricted to specific roles (like the borrower or admin) may not have adequate access control checks, allowing unauthorized users to perform sensitive actions.

3. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to unexpected results if not handled correctly, especially in cases where the SafeMath library is not applied.

4. **Lack of Input Validation**:
   - Functions that accept user inputs (like amounts to lend or borrow) do not have sufficient checks to ensure that the inputs are valid (e.g., non-zero, within limits), which could lead to unexpected behaviors or state corruption.

5. **State Manipulation**:
   - Certain functions may allow users to manipulate the state of the contract in ways that are not intended, such as starting a PCL (Pooled Credit Line) after it has ended or canceling requests in inappropriate states.

6. **Gas Limit Issues**:
   - Some functions may consume excessive gas, especially those that involve loops or complex calculations, which could lead to transaction failures if the gas limit is exceeded.

7. **Event Emission**:
   - There are instances where important state changes are not accompanied by event emissions, which could hinder tracking and auditing of contract activities.

8. **Lack of Fallback Functions**:
   - The contract may not have a fallback function to handle unexpected Ether transfers, which could lead to loss of funds if users mistakenly send Ether to the contract.

### Comprehensive Analysis Report

The analysis of the provided smart contract code reveals several critical security vulnerabilities that could potentially be exploited by malicious actors. The most pressing issues include the lack of reentrancy protection, which poses a significant risk during token transfer operations. Additionally, improper access control mechanisms could allow unauthorized users to execute sensitive functions, leading to unauthorized fund manipulation.

The use of SafeMath mitigates the risk of integer overflow and underflow; however, the reliance on it should be consistent throughout the contract to ensure all arithmetic operations are safe. Input validation is another area of concern, as insufficient checks on user inputs could lead to unexpected contract states or even loss of funds.

Moreover, the potential for state manipulation is alarming, particularly in functions that allow users to start or cancel PCLs in inappropriate states. This could undermine the integrity of the lending process and lead to financial losses for both lenders and borrowers.

Gas limit issues could also arise, particularly in functions that involve complex calculations or loops, which may lead to transaction failures. Furthermore, the absence of event emissions for critical state changes could hinder transparency and make it difficult to audit contract activities.

Lastly, the lack of a fallback function to handle unexpected Ether transfers could result in the loss of funds, as users may inadvertently send Ether to the contract.

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, code refactoring, and the implementation of best practices in smart contract development. This will enhance the security and reliability of the contract, ultimately protecting users and their funds.

[2024-27-08 09:29:58 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement a proper reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, leading to unexpected behaviors or loss of funds.

2. **Improper Access Control**:
   - Functions that should be restricted to specific roles (like the borrower or admin) may not have adequate access control checks, allowing unauthorized users to perform sensitive actions.

3. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to unexpected results if not handled correctly, especially in cases where the SafeMath library is not applied.

4. **Lack of Input Validation**:
   - Functions that accept user inputs (like amounts to lend or borrow) do not have sufficient checks to ensure that the inputs are valid (e.g., non-zero, within limits), which could lead to unexpected behaviors or state corruption.

5. **State Manipulation**:
   - Certain functions may allow users to manipulate the state of the contract in ways that are not intended, such as starting a PCL (Pooled Credit Line) after it has ended or canceling requests in inappropriate states.

6. **Gas Limit Issues**:
   - Some functions may consume excessive gas, especially those that involve loops or complex calculations, which could lead to transaction failures if the gas limit is exceeded.

7. **Event Emission**:
   - There are instances where important state changes are not accompanied by event emissions, which could hinder tracking and auditing of contract activities.

8. **Lack of Fallback Functions**:
   - The contract may not have a fallback function to handle unexpected Ether transfers, which could lead to loss of funds if users mistakenly send Ether to the contract.

### Comprehensive Analysis Report

The analysis of the provided smart contract code reveals several critical security vulnerabilities that could potentially be exploited by malicious actors. The most pressing issues include the lack of reentrancy protection, which poses a significant risk during token transfer operations. Additionally, improper access control mechanisms could allow unauthorized users to execute sensitive functions, leading to unauthorized fund manipulation.

The use of SafeMath mitigates the risk of integer overflow and underflow; however, the reliance on it should be consistent throughout the contract to ensure all arithmetic operations are safe. Input validation is another area of concern, as insufficient checks on user inputs could lead to unexpected contract states or even loss of funds.

Moreover, the potential for state manipulation is alarming, particularly in functions that allow users to start or cancel PCLs in inappropriate states. This could undermine the integrity of the lending process and lead to financial losses for both lenders and borrowers.

Gas limit issues could also arise, particularly in functions that involve complex calculations or loops, which may lead to transaction failures. Furthermore, the absence of event emissions for critical state changes could hinder transparency and make it difficult to audit contract activities.

Lastly, the lack of a fallback function to handle unexpected Ether transfers could result in the loss of funds, as users may inadvertently send Ether to the contract.

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, code refactoring, and the implementation of best practices in smart contract development. This will enhance the security and reliability of the contract, ultimately protecting users and their funds.

[2024-27-08 09:30:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\n\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../Roles/MaliciousLender.sol\';\n\ncontract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_cannotStartAfterEndsAt() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.start(requestId) {\n            revert(\'Cannot start PCL once it has ended\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S3\');\n        }\n    }\n\n    /*******************\n    Deposit collateral function tests\n    *******************/\n\n    function assert_collateralCannotBeDepositedInRequestedState(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        // Since the PCL is in the REQUESTED state, let us start some lending\n        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);\n\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);\n\n        try _depositor.depositCollateral(_id, _collateralRequired, false) {\n            revert(\'Collateral cannot be deposited in the REQUESTED state\');\n        } catch Error(string memory reason) {\n            if (request.collateralRatio == 0) {\n                assertEq(reason, \'PCL:DC1\');\n            } else {\n                assertEq(reason, \'PCL:DC2\');\n            }\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToBorrow = 100_000 * 1e18;\n        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);\n    }\n\n    /*******************\n    Start/proceed to Active state function tests\n    *******************/\n\n    function assert_start_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _numOfLenders,\n        uint128 _lendAmount,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert,\n        PCLUser _starter,\n        bool _positiveCase,\n        string memory _revertStatement,\n        string memory _errorMessage\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_lendAmount &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);\n\n        if (!_positiveCase) {\n            try _starter.start(_id) {\n                revert(_revertStatement);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _starter.start(_id);\n        }\n    }\n\n    // Test 3.1\n    function test_cannotStartAlreadyActivePCL() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            borrower,\n            false,\n            \'PCL cannot be started again\',\n            \'LP:S1\'\n        );\n    }\n\n    // Test 3.2\n    function test_cannotStartPCLInCollectionPeriod() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            2,\n            request.borrowLimit - 1,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            admin,\n            false,\n            \'PCL cannot be started in collection period\',\n            \'LP:S2\'\n        );\n    }\n\n    // Test 3.3\n    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            false,\n            \'PCL cannot be started for an amount less than minBorrowAmount\',\n            \'LP:S4\'\n        );\n    }\n\n    // Test 3.4\n    function test_startPCLPositiveCase() public {\n        assert_start_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.minBorrowAmount + 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            borrower,\n            true,\n            \'\',\n            \'\'\n        );\n    }\n\n    function test_lenderCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser lender = PCLUser(lenders[0].lenderAddress);\n\n        try lender.start(requestId) {\n            revert("Lender shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_adminCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser admin = PCLUser(admin);\n\n        try admin.start(requestId) {\n            revert("Admin shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    function test_randomUserCannotStart() public {\n        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        try randomUser.start(requestId) {\n            revert("Random user shouldn\'t be able to start PCL");\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:A2\');\n        }\n    }\n\n    /*******************\n    Cancel function tests\n    *******************/\n\n    function assert_cancel_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_amountToLend &gt;= request.borrowLimit) {\n            borrower.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (!_positiveCase) {\n            try _user.cancelRequest(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.cancelRequest(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 4.1\n    function test_borrowerCannotCancelActivePCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            4,\n            request.borrowLimit + 10,\n            request.collectionPeriod,\n            PooledCreditLineStatus.ACTIVE,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR1\',\n            PooledCreditLineStatus.ACTIVE\n        );\n    }\n\n    // Test 4.2\n    function test_borrowerCannotCancelPostCollectionPeriod() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            6,\n            uint128(request.minBorrowAmount - 1),\n            (request.collectionPeriod + 2 days),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'PCL can be cancelled only in the REQUESTED state\',\n            \'PCL:CR2\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.3\n    function test_lenderCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.4\n    function test_adminCannotCancelPCL() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            false,\n            \'Only borrower can cancel PCL\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 4.5\n    function test_cancelPCLPositiveCase() public {\n        assert_cancel_functionality_in_requested_state(\n            requestId,\n            5,\n            uint128(request.borrowLimit - 100),\n            (request.collectionPeriod / 2),\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    /*******************\n    Liquidity Withdrawal function tests\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_request_state(\n        uint256 _id,\n        bool _isLender,\n        PCLUser _user,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        // complex test - code can be simplified\n        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n\n        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);\n\n        if (!_positiveCase) {\n            try admin.withdrawLiquidity(requestId) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            // the pcl will get cancelled because of low collection\n            _user.withdrawLiquidity(_id);\n            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);\n\n            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);\n            assertEq(_userPoolTokenBalance, 0);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 5.1\n    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            true,\n            PCLUser(lenders[0].lenderAddress),\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CANCELLED\n        );\n    }\n\n    // Test 5.2\n    function test_adminCannotWithdrawLiquidityInRequestedState() public {\n        assert_withdraw_liquidity_functionality_in_request_state(\n            requestId,\n            false,\n            admin,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'Admin withdrew liquidity\',\n            \'LP:IWL1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Close function tests\n    *******************/\n\n    function assert_close_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        bool _isLender,\n        PCLUser _user,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        if (_positiveCase) {\n            _user.start(_id);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.close(_id);\n        } else {\n            try _user.close(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 6.1\n    function test_borrowerCannotCloseRequestedPCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            false,\n            borrower,\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed in the ACTIVE state\',\n            \'PCL:C1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.2\n    function test_borrowerCanCloseActivePCLPositiveCase() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.borrowLimit + 1),\n            false,\n            borrower,\n            (request.collectionPeriod),\n            PooledCreditLineStatus.ACTIVE,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.CLOSED\n        );\n    }\n\n    // Test 6.3\n    function test_lenderCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            true,\n            PCLUser(address(0)),\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by a lender\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 6.4\n    function test_adminCannotClosePCL() public {\n        assert_close_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            false,\n            admin,\n            0,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            \'PCL cannot be closed by admin\',\n            \'PCL:OCLB1\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        bool _isLender,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    // Test 7.1: Call Liquidate function in REQUESTED state\n    function test_callLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            true,\n            PCLUser(address(0)),\n            \'Borrower cannot be liquidated without borrowing first\',\n            \'PCL:L1\'\n        );\n    }\n\n    // Test 7.2: Borrower calls liquidate function in the REQUESTED state\n    function test_borrowerCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            borrower,\n            \'Borrower cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    // Test 7.3: Admin calls liquidate function in the REQUESTED state\n    function test_adminCallsLiquidateInRequestedState() public {\n        assert_liquidate_functionality_in_requested_state(\n            requestId,\n            3,\n            uint128(request.minBorrowAmount - 100),\n            request.collectionPeriod,\n            false,\n            admin,\n            \'Admin cannot liquidate a PCL\',\n            \'LP:LIQ1\'\n        );\n    }\n\n    function test_callLiquidateAfterTransferringPoolTokens() public {\n        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n\n        // Warping past the collection period\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // Check whether the PCL went into the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);\n\n        // Picking out two lenders from the list of 4 lenders\n        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);\n\n        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);\n\n        log_named_uint(\'Lender_0 Pool MockToken Balance-1\', lender_0_pool_token_balance);\n\n        // lender_0 tries to transfer their pool tokens to lender_1\n        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);\n\n        // Lender_0 calls the liquidate function\n        try lender_0.liquidate(requestId, false) {\n            revert(\'Lender with 0 pool tokens cannot liquidate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:LIQ1\');\n        }\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInRequestedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, admin, \'Admin cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_borrowerCannotRepay() public {\n        assertRepayFunctionalityInRequestedState(requestId, borrower, \'Borrower cannot repay a requested PCL\', \'PCL:REP2\');\n    }\n\n    function test_lenderCannotRepay() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertRepayFunctionalityInRequestedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot repay a requested PCL\',\n            \'PCL:REP2\'\n        );\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, \'Admin cannot borrow a PCL in requested state\', \'PCL:OCLB1\');\n    }\n\n    function test_borrowerCannotBorrowAfterStartTimestamp() public {\n        vm.warp(block.timestamp + request.collectionPeriod);\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB3\');\n    }\n\n    function test_borrowerCannotBorrow() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB2\');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in requested state\', \'PCL:IB1\');\n    }\n\n    function test_lenderCannotBorrow() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertBorrowFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in requested state\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInRequestedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        try _user.withdrawAllCollateral(_id, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessageAll);\n        }\n\n        try _user.withdrawCollateral(_id, _amount, false) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in requested state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);\n        assertWithdrawCollateralFunctionalityInRequestedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in requested state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n\n    /*******************\n    Terminate function tests\n    *******************/\n\n    function assert_terminate_functionality_in_requested_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration,\n        PooledCreditLineStatus _stateToAssert_1,\n        bool _isLender,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        PooledCreditLineStatus _stateToAssert_2\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);\n\n        if (_isLender) {\n            _user = PCLUser(lenders[0].lenderAddress);\n        }\n\n        if (_positiveCase) {\n            _user.terminate(_id);\n            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);\n            // assertEq(_params.borrowAsset, address(0));\n        } else {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);\n    }\n\n    // Test 8.1: Admin can terminate the PCL in requested state\n    function test_terminationInRequestedState() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            admin,\n            true,\n            \'\',\n            \'\',\n            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.\n        );\n    }\n\n    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByLender() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            true,\n            PCLUser(address(0)),\n            false,\n            \'Lender cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state\n    function test_terminationInRequestedStateByBorrower() public {\n        assert_terminate_functionality_in_requested_state(\n            requestId,\n            4,\n            uint128(request.minBorrowAmount - 1),\n            request.collectionPeriod,\n            PooledCreditLineStatus.REQUESTED,\n            false,\n            borrower,\n            false,\n            \'Borrower cannot terminate PCLs\',\n            \'Ownable: caller is not the owner\',\n            PooledCreditLineStatus.REQUESTED\n        );\n    }\n\n    /*******************\n    View/Calculation function tests\n    *******************/\n\n    uint256 _currentCR;\n    uint256 _collateralTokensToLiquidate;\n\n    function assert_helper_functionalities_in_request_state(\n        uint256 _id,\n        uint256 _noOfLenders,\n        uint128 _amountToLend,\n        uint256 _travelDuration\n    ) public {\n        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        vm.warp(block.timestamp + _travelDuration);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        emit log_named_uint(\'_userLiquidity: \', _userLiquidity);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        if (_amountToLend &lt; request.minBorrowAmount) {\n            assertEq(_principalWithdrawable, _userLiquidity);\n        } else {\n            assertEq(_principalWithdrawable, 0);\n        }\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0);\n\n        // 3. calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0);\n\n        {\n            // 5. calculateInterestAccrued\n            assertEq(_borrower.calculateInterestAccrued(_id), 0);\n        }\n\n        {\n            // 6. calculateCurrentDebt\n            assertEq(_borrower.calculateCurrentDebt(_id), 0);\n        }\n\n        // 7. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR, uint256(-1));\n\n        // 8. collateralTokensToLiquidate\n        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n        assertEq(_collateralTokensToLiquidate, 0);\n    }\n\n    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {\n        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));\n\n        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);\n    }\n\n    /*******************\n    Pool MockToken Transfer tests\n    *******************/\n\n    function assert_pool_transfers_in_requested_state(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _fromUserPoolTokenSupply;\n        uint256 _toUserPoolTokenSupply;\n        uint256 _fromUserPoolTokenSupplyNew;\n        uint256 _toUserPoolTokenSupplyNew;\n\n        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);\n\n        vm.warp(block.timestamp + request.collectionPeriod + 2 days);\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);\n\n        if (address(_fromUser) == address(0)) {\n            _fromUser = PCLUser(lenders[0].lenderAddress);\n        }\n        if (address(_toUser) == address(0)) {\n            _toUser = PCLUser(lenders[1].lenderAddress);\n        }\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    // Test 10.1:\n    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {\n        assert_pool_transfers_in_requested_state(\n            requestId,\n            PCLUser(address(0)),\n            admin,\n            false,\n            1,\n            \'Admin should not be able to recieve pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n\n    // Test 10.2:\n    function test_poolTokenTransferInRequestedStatePossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, \'\', \'\');\n    }\n\n    // Test 10.3:\n    function test_partialPoolTokenTransferPossible() public {\n        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, \'\', \'\');\n    }\n\n    function test_pooledCreditLine_onERC1155ReceivedHook() public {\n        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {\n            revert(\'REVERT: should have reverted\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ReentrancyGuard: reentrant call\');\n        }\n    }\n\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n\n    function test_withdrawLiquidityAfterPclHasEnded() public {\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S3\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityOnLowCollection() public {\n        // lend less than minBorrowAmount\n        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);\n        // go to start time\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl cannot be started\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        vm.expectRevert(bytes(\'LP:S4\'));\n        _lender.start(requestId);\n\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);\n\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);\n        // liquidate\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_withdrawLiquidityReverted() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        // make sure pcl has not been started\n        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        assertGe(_lenderLpBalance, 0);\n        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);\n\n        vm.expectRevert(bytes(\'LP:IWL3\'));\n        _lender.withdrawLiquidity(requestId);\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n\n    function test_cannotLendAfterCollectionPeriod() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        vm.warp(block.timestamp + request.collectionPeriod);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend after collection period\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n\n    function test_cannotLendIfBorrowLimitReached() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);\n\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend if borrow limit is reached\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L4\');\n        }\n    }\n\n    function test_lenderCannotWithdrawInterest() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        uint256 _requestId = borrower.createRequest(request);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);\n\n        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:30:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../Roles/MaliciousLender.sol'; contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId; uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED); }  function test_cannotStartAfterEndsAt() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.start(requestId) {         revert('Cannot start PCL once it has ended');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S3');     } }  /************************************************************************************************************************************** Deposit collateral function tests **************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInRequestedState(     uint256 _id,     uint256 _amountToBorrow,     PCLUser _depositor,     bool _isDepositorLender ) public {     // Since the PCL is in the REQUESTED state, let us start some lending     createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);      uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);     _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);      try _depositor.depositCollateral(_id, _collateralRequired, false) {         revert('Collateral cannot be deposited in the REQUESTED state');     } catch Error(string memory reason) {         if (request.collateralRatio == 0) {             assertEq(reason, 'PCL:DC1');         } else {             assertEq(reason, 'PCL:DC2');         }     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToBorrow = 100_000 * 1e18;     assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false); }  /************************************************************************************************************************************** Start/proceed to Active state function tests **************************************************************************************************************************************/  function assert_start_functionality_in_requested_state(     uint256 _id,     uint256 _numOfLenders,     uint128 _lendAmount,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert,     PCLUser _starter,     bool _positiveCase,     string memory _revertStatement,     string memory _errorMessage ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_lendAmount &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);      if (!_positiveCase) {         try _starter.start(_id) {             revert(_revertStatement);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _starter.start(_id);     } }  // Test 3.1 function test_cannotStartAlreadyActivePCL() public {     assert_start_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         borrower,         false,         'PCL cannot be started again',         'LP:S1'     ); }  // Test 3.2 function test_cannotStartPCLInCollectionPeriod() public {     assert_start_functionality_in_requested_state(         requestId,         2,         request.borrowLimit - 1,         0,         PooledCreditLineStatus.REQUESTED,         admin,         false,         'PCL cannot be started in collection period',         'LP:S2'     ); }  // Test 3.3 function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         false,         'PCL cannot be started for an amount less than minBorrowAmount',         'LP:S4'     ); }  // Test 3.4 function test_startPCLPositiveCase() public {     assert_start_functionality_in_requested_state(         requestId,         5,         uint128(request.minBorrowAmount + 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         borrower,         true,         '',         ''     ); }  function test_lenderCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser lender = PCLUser(lenders[0].lenderAddress);      try lender.start(requestId) {         revert("Lender shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_adminCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser admin = PCLUser(admin);      try admin.start(requestId) {         revert("Admin shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  function test_randomUserCannotStart() public {     createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod);      PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      try randomUser.start(requestId) {         revert("Random user shouldn't be able to start PCL");     } catch Error(string memory reason) {         assertEq(reason, 'PCL:A2');     } }  /************************************************************************************************************************************** Cancel function tests **************************************************************************************************************************************/  function assert_cancel_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified      createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_amountToLend &gt;= request.borrowLimit) {         borrower.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (!_positiveCase) {         try _user.cancelRequest(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.cancelRequest(_id);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 4.1 function test_borrowerCannotCancelActivePCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         4,         request.borrowLimit + 10,         request.collectionPeriod,         PooledCreditLineStatus.ACTIVE,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR1',         PooledCreditLineStatus.ACTIVE     ); }  // Test 4.2 function test_borrowerCannotCancelPostCollectionPeriod() public {     assert_cancel_functionality_in_requested_state(         requestId,         6,         uint128(request.minBorrowAmount - 1),         (request.collectionPeriod + 2 days),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'PCL can be cancelled only in the REQUESTED state',         'PCL:CR2',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.3 function test_lenderCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.4 function test_adminCannotCancelPCL() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         admin,         false,         'Only borrower can cancel PCL',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 4.5 function test_cancelPCLPositiveCase() public {     assert_cancel_functionality_in_requested_state(         requestId,         5,         uint128(request.borrowLimit - 100),         (request.collectionPeriod / 2),         PooledCreditLineStatus.REQUESTED,         false,         borrower,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  /************************************************************************************************************************************** Liquidity Withdrawal function tests **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_request_state(     uint256 _id,     bool _isLender,     PCLUser _user,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     // complex test - code can be simplified     createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);      vm.warp(block.timestamp + (request.collectionPeriod + 2 days));      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);      if (!_positiveCase) {         try admin.withdrawLiquidity(requestId) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         // the pcl will get cancelled because of low collection         _user.withdrawLiquidity(_id);         uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));         assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);          _userPoolTokenBalance = lp.balanceOf(address(_user), _id);         assertEq(_userPoolTokenBalance, 0);     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 5.1 function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         true,         PCLUser(lenders[0].lenderAddress),         PooledCreditLineStatus.REQUESTED,         true,         '',         '',         PooledCreditLineStatus.CANCELLED     ); }  // Test 5.2 function test_adminCannotWithdrawLiquidityInRequestedState() public {     assert_withdraw_liquidity_functionality_in_request_state(         requestId,         false,         admin,         PooledCreditLineStatus.REQUESTED,         false,         'Admin withdrew liquidity',         'LP:IWL1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Close function tests **************************************************************************************************************************************/  function assert_close_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     bool _isLender,     PCLUser _user,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      if (_positiveCase) {         _user.start(_id);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.close(_id);     } else {         try _user.close(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 6.1 function test_borrowerCannotCloseRequestedPCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         false,         borrower,         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed in the ACTIVE state',         'PCL:C1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.2 function test_borrowerCanCloseActivePCLPositiveCase() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.borrowLimit + 1),         false,         borrower,         (request.collectionPeriod),         PooledCreditLineStatus.ACTIVE,         true,         '',         '',         PooledCreditLineStatus.CLOSED     ); }  // Test 6.3 function test_lenderCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         true,         PCLUser(address(0)),         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by a lender',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  // Test 6.4 function test_adminCannotClosePCL() public {     assert_close_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         false,         admin,         0,         PooledCreditLineStatus.REQUESTED,         false,         'PCL cannot be closed by admin',         'PCL:OCLB1',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     bool _isLender,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  // Test 7.1: Call Liquidate function in REQUESTED state function test_callLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         true,         PCLUser(address(0)),         'Borrower cannot be liquidated without borrowing first',         'PCL:L1'     ); }  // Test 7.2: Borrower calls liquidate function in the REQUESTED state function test_borrowerCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         borrower,         'Borrower cannot liquidate a PCL',         'LP:LIQ1'     ); }  // Test 7.3: Admin calls liquidate function in the REQUESTED state function test_adminCallsLiquidateInRequestedState() public {     assert_liquidate_functionality_in_requested_state(         requestId,         3,         uint128(request.minBorrowAmount - 100),         request.collectionPeriod,         false,         admin,         'Admin cannot liquidate a PCL',         'LP:LIQ1'     ); }  function test_callLiquidateAfterTransferringPoolTokens() public {     // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);      // Warping past the collection period     vm.warp(block.timestamp + request.collectionPeriod);      // Check whether the PCL went into the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);      // Picking out two lenders from the list of 4 lenders     PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);      uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);      log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);      // lender_0 tries to transfer their pool tokens to lender_1     lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);      // Lender_0 calls the liquidate function     try lender_0.liquidate(requestId, false) {         revert('Lender with 0 pool tokens cannot liquidate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:LIQ1');     } }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInRequestedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2'); }  function test_borrowerCannotRepay() public {     assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2'); }  function test_lenderCannotRepay() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertRepayFunctionalityInRequestedState(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot repay a requested PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAfterStartTimestamp() public {     vm.warp(block.timestamp + request.collectionPeriod);     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3'); }  function test_borrowerCannotBorrow() public {     assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertBorrowFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in requested state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInRequestedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     try _user.withdrawAllCollateral(_id, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessageAll);     }      try _user.withdrawCollateral(_id, _amount, false) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in requested state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);     assertWithdrawCollateralFunctionalityInRequestedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in requested state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_requested_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration,     PooledCreditLineStatus _stateToAssert_1,     bool _isLender,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage,     PooledCreditLineStatus _stateToAssert_2 ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);      if (_isLender) {         _user = PCLUser(lenders[0].lenderAddress);     }      if (_positiveCase) {         _user.terminate(_id);         // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);         // assertEq(_params.borrowAsset, address(0));     } else {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2); }  // Test 8.1: Admin can terminate the PCL in requested state function test_terminationInRequestedState() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         admin,         true,         '',         '',         PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.     ); }  // Test 8.2: Lender cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByLender() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         true,         PCLUser(address(0)),         false,         'Lender cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state function test_terminationInRequestedStateByBorrower() public {     assert_terminate_functionality_in_requested_state(         requestId,         4,         uint128(request.minBorrowAmount - 1),         request.collectionPeriod,         PooledCreditLineStatus.REQUESTED,         false,         borrower,         false,         'Borrower cannot terminate PCLs',         'Ownable: caller is not the owner',         PooledCreditLineStatus.REQUESTED     ); }  /************************************************************************************************************************************** View/Calculation function tests **************************************************************************************************************************************/  uint256 _currentCR; uint256 _collateralTokensToLiquidate;  function assert_helper_functionalities_in_request_state(     uint256 _id,     uint256 _noOfLenders,     uint128 _amountToLend,     uint256 _travelDuration ) public {     createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;     vm.warp(block.timestamp + _travelDuration);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     emit log_named_uint('_userLiquidity: ', _userLiquidity);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     if (_amountToLend &lt; request.minBorrowAmount) {         assertEq(_principalWithdrawable, _userLiquidity);     } else {         assertEq(_principalWithdrawable, 0);     }      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0);      // 3. calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0);      {         // 5. calculateInterestAccrued         assertEq(_borrower.calculateInterestAccrued(_id), 0);     }      {         // 6. calculateCurrentDebt         assertEq(_borrower.calculateCurrentDebt(_id), 0);     }      // 7. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR, uint256(-1));      // 8. collateralTokensToLiquidate     _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);     assertEq(_collateralTokensToLiquidate, 0); }  function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {     _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));      assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days); }  /************************************************************************************************************************************** Pool MockToken Transfer tests **************************************************************************************************************************************/  function assert_pool_transfers_in_requested_state(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _fromUserPoolTokenSupply;     uint256 _toUserPoolTokenSupply;     uint256 _fromUserPoolTokenSupplyNew;     uint256 _toUserPoolTokenSupplyNew;      createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);      vm.warp(block.timestamp + request.collectionPeriod + 2 days);      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);      if (address(_fromUser) == address(0)) {         _fromUser = PCLUser(lenders[0].lenderAddress);     }     if (address(_toUser) == address(0)) {         _toUser = PCLUser(lenders[1].lenderAddress);     }      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  // Test 10.1: function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {     assert_pool_transfers_in_requested_state(         requestId,         PCLUser(address(0)),         admin,         false,         1,         'Admin should not be able to recieve pool tokens',         'LP:IT3'     ); }  // Test 10.2: function test_poolTokenTransferInRequestedStatePossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', ''); }  // Test 10.3: function test_partialPoolTokenTransferPossible() public {     assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', ''); }  function test_pooledCreditLine_onERC1155ReceivedHook() public {     PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {         revert('REVERT: should have reverted');     } catch Error(string memory reason) {         assertEq(reason, 'ReentrancyGuard: reentrant call');     } }  event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason); event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);  function test_withdrawLiquidityAfterPclHasEnded() public {     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod + request.duration);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S3'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);      assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityOnLowCollection() public {     // lend less than minBorrowAmount     createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);     // go to start time     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl cannot be started     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     vm.expectRevert(bytes('LP:S4'));     _lender.start(requestId);      uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);      vm.expectEmit(true, true, false, true);     emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);     vm.expectEmit(true, true, true, true);     emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);     // liquidate     _lender.withdrawLiquidity(requestId); }  function test_withdrawLiquidityReverted() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);     vm.warp(block.timestamp + request.collectionPeriod);      // make sure pcl has not been started     assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     assertGe(_lenderLpBalance, 0);     assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);      vm.expectRevert(bytes('LP:IWL3'));     _lender.withdrawLiquidity(requestId); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_cannotLendAfterCollectionPeriod() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      vm.warp(block.timestamp + request.collectionPeriod);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend after collection period');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendIfBorrowLimitReached() public {     createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);      uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend if borrow limit is reached');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L4');     } }  function test_lenderCannotWithdrawInterest() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     uint256 _requestId = borrower.createRequest(request);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);      createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:30:02 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert("Lender shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert("Admin shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert("Random user shouldn't be able to start PCL");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

